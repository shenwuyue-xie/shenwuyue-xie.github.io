{"meta":{"title":"かんなづき","subtitle":null,"description":null,"author":"神无月","url":"http://localhost:4000","root":"/"},"pages":[{"title":"about","date":"2018-12-12T14:14:36.000Z","updated":"2021-11-09T14:13:18.000Z","comments":false,"path":"about/index.html","permalink":"http://localhost:4000/about/index.html","excerpt":"","text":"[さくら荘のhojun] 与&nbsp; Mashiro&nbsp; （ 真（ま）白（しろ） ） 对话中... bot_ui_ini()"},{"title":"bangumi","date":"2019-02-10T13:32:48.000Z","updated":"2021-11-09T14:13:18.000Z","comments":false,"path":"bangumi/index.html","permalink":"http://localhost:4000/bangumi/index.html","excerpt":"","text":""},{"title":"client","date":"2018-12-20T15:13:35.000Z","updated":"2021-11-09T14:13:18.000Z","comments":false,"path":"client/index.html","permalink":"http://localhost:4000/client/index.html","excerpt":"","text":"直接下载 or 扫码下载："},{"title":"categories","date":"2022-08-17T05:44:11.927Z","updated":"2022-08-16T11:43:52.491Z","comments":true,"path":"categories/index.html","permalink":"http://localhost:4000/categories/index.html","excerpt":"","text":""},{"title":"donate","date":"2018-12-20T15:13:05.000Z","updated":"2021-11-09T14:13:18.000Z","comments":false,"path":"donate/index.html","permalink":"http://localhost:4000/donate/index.html","excerpt":"","text":""},{"title":"comment","date":"2018-12-20T15:13:48.000Z","updated":"2021-11-09T14:13:18.000Z","comments":true,"path":"comment/index.html","permalink":"http://localhost:4000/comment/index.html","excerpt":"","text":"念两句诗 叙别梦、扬州一觉。 【宋代】吴文英《夜游宫·人去西楼雁杳》"},{"title":"lab","date":"2019-01-05T13:47:59.000Z","updated":"2021-11-09T14:13:18.000Z","comments":false,"path":"lab/index.html","permalink":"http://localhost:4000/lab/index.html","excerpt":"","text":"sakura主题balabala"},{"title":"music","date":"2018-12-20T15:14:28.000Z","updated":"2021-11-09T14:13:18.000Z","comments":false,"path":"music/index.html","permalink":"http://localhost:4000/music/index.html","excerpt":"","text":""},{"title":"links","date":"2018-12-19T15:11:06.000Z","updated":"2021-11-09T14:13:18.000Z","comments":true,"path":"links/index.html","permalink":"http://localhost:4000/links/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-12-12T14:14:16.000Z","updated":"2021-11-09T14:13:18.000Z","comments":true,"path":"tags/index.html","permalink":"http://localhost:4000/tags/index.html","excerpt":"","text":""},{"title":"rss","date":"2018-12-20T15:09:03.000Z","updated":"2021-11-09T14:13:18.000Z","comments":true,"path":"rss/index.html","permalink":"http://localhost:4000/rss/index.html","excerpt":"","text":""},{"title":"theme-sakura","date":"2019-01-04T14:53:25.000Z","updated":"2021-11-09T14:13:18.000Z","comments":false,"path":"theme-sakura/index.html","permalink":"http://localhost:4000/theme-sakura/index.html","excerpt":"","text":"Hexo主题Sakura修改自WordPress主题Sakura，感谢原作者Mashiro"},{"title":"video","date":"2018-12-20T15:14:38.000Z","updated":"2021-11-09T14:13:18.000Z","comments":false,"path":"video/index.html","permalink":"http://localhost:4000/video/index.html","excerpt":"","text":"var videos = [ { img: 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '放送时间: 2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' }, { img : 'https://lain.bgm.tv/pic/cover/l/0e/1e/218971_2y351.jpg', title: '朝花夕誓——于离别之朝束起约定之花', status: '已追完', progress: 100, jp: 'さよならの朝に約束の花をかざろう', time: '2018-02-24 SUN.', desc: ' 住在远离尘嚣的土地，一边将每天的事情编织成名为希比欧的布，一边静静生活的伊欧夫人民。在15岁左右外表就停止成长，拥有数百年寿命的他们，被称为“离别的一族”，并被视为活着的传说。没有双亲的伊欧夫少女玛奇亚，过着被伙伴包围的平稳日子，却总感觉“孤身一人”。他们的这种日常，一瞬间就崩溃消失。追求伊欧夫的长寿之血，梅萨蒂军乘坐着名为雷纳特的古代兽发动了进攻。在绝望与混乱之中，伊欧夫的第一美女蕾莉亚被梅萨蒂带走，而玛奇亚暗恋的少年克里姆也失踪了。玛奇亚虽然总算逃脱了，却失去了伙伴和归去之地……。' } ] .should-ellipsis{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:95%;}.should-ellipsis-full{overflow:hidden;text-overflow:ellipsis;white-space:nowrap;width:100%;}.should-ellipsis i{position:absolute;right:24px;}.grey-text{color:#9e9e9e !important}.grey-text.text-darken-4{color:#212121 !important}html{line-height:1.15;-ms-text-size-adjust:100%;-webkit-text-size-adjust:100%}body{margin:0}img{border-style:none}progress{display:inline-block;vertical-align:baseline}::-webkit-file-upload-button{-webkit-appearance:button;font:inherit}html{-webkit-box-sizing:border-box;box-sizing:border-box}*,*:before,*:after{-webkit-box-sizing:inherit;box-sizing:inherit}ul:not(.browser-default){padding-left:0;list-style-type:none}ul:not(.browser-default)>li{list-style-type:none}.card{-webkit-box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2);box-shadow:0 2px 2px 0 rgba(0,0,0,0.14),0 3px 1px -2px rgba(0,0,0,0.12),0 1px 5px 0 rgba(0,0,0,0.2)}.hoverable{-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s}.hoverable:hover{-webkit-box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19);box-shadow:0 8px 17px 0 rgba(0,0,0,0.2),0 6px 20px 0 rgba(0,0,0,0.19)}i{line-height:inherit}i.right{float:right;margin-left:15px}.bangumi .right{float:right !important}.material-icons{text-rendering:optimizeLegibility;-webkit-font-feature-settings:'liga';-moz-font-feature-settings:'liga';font-feature-settings:'liga'}.row{margin-left:auto;margin-right:auto;margin-bottom:20px}.row:after{content:\"\";display:table;clear:both}.row .col{float:left;-webkit-box-sizing:border-box;box-sizing:border-box;padding:0 .75rem;min-height:1px}.row .col.s12{width:100%;margin-left:auto;left:auto;right:auto}@media only screen and (min-width:601px){.row .col.m6{width:50%;margin-left:auto;left:auto;right:auto}}html{line-height:1.5;font-family:-apple-system,BlinkMacSystemFont,\"Segoe UI\",Roboto,Oxygen-Sans,Ubuntu,Cantarell,\"Helvetica Neue\",sans-serif;font-weight:normal;color:rgba(0,0,0,0.87)}@media only screen and (min-width:0){html{font-size:14px}}@media only screen and (min-width:992px){html{font-size:14.5px}}@media only screen and (min-width:1200px){html{font-size:15px}}.card{position:relative;margin:.5rem 0 1rem 0;background-color:#fff;-webkit-transition:-webkit-box-shadow .25s;transition:-webkit-box-shadow .25s;transition:box-shadow .25s;transition:box-shadow .25s,-webkit-box-shadow .25s;border-radius:2px}.card .card-title{font-size:24px;font-weight:300}.card .card-title.activator{cursor:pointer}.card .card-image{position:relative}.card .card-image img{display:block;border-radius:2px 2px 0 0;position:relative;left:0;right:0;top:0;bottom:0;width:100%}.card .card-content{padding:24px;border-radius:0 0 2px 2px}.card .card-content p{margin:0}.card .card-content .card-title{display:block;line-height:32px;margin-bottom:8px}.card .card-content .card-title i{line-height:32px}.card .card-reveal{padding:24px;position:absolute;background-color:#fff;width:100%;overflow-y:auto;left:0;top:100%;height:100%;z-index:3;display:none}.card .card-reveal .card-title{cursor:pointer;display:block}.waves-effect{position:relative;cursor:pointer;display:inline-block;overflow:hidden;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-tap-highlight-color:transparent;vertical-align:middle;z-index:1;-webkit-transition:.3s ease-out;transition:.3s ease-out}.waves-effect img{position:relative;z-index:-1}.waves-block{display:block}::-webkit-input-placeholder{color:#d1d1d1}::-moz-placeholder{color:#d1d1d1}:-ms-input-placeholder{color:#d1d1d1}::-ms-input-placeholder{color:#d1d1d1}[type=\"radio\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"radio\"]:not(:checked)+span{position:relative;padding-left:35px;cursor:pointer;display:inline-block;height:25px;line-height:25px;font-size:1rem;-webkit-transition:.28s ease;transition:.28s ease;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border-radius:50%}[type=\"radio\"]:not(:checked)+span:before,[type=\"radio\"]:not(:checked)+span:after{border:2px solid #5a5a5a}[type=\"radio\"]:not(:checked)+span:after{-webkit-transform:scale(0);transform:scale(0)}[type=\"checkbox\"]:not(:checked){position:absolute;opacity:0;pointer-events:none}[type=\"checkbox\"]:not(:checked):disabled+span:not(.lever):before{border:none;background-color:rgba(0,0,0,0.42)}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):before{width:0;height:0;border:3px solid transparent;left:6px;top:10px;-webkit-transform:rotateZ(37deg);transform:rotateZ(37deg);-webkit-transform-origin:100% 100%;transform-origin:100% 100%}[type=\"checkbox\"].filled-in:not(:checked)+span:not(.lever):after{height:20px;width:20px;background-color:transparent;border:2px solid #5a5a5a;top:0px;z-index:0}input[type=checkbox]:not(:disabled) ~ .lever:active:before,input[type=checkbox]:not(:disabled).tabbed:focus ~ .lever::before{-webkit-transform:scale(2.4);transform:scale(2.4);background-color:rgba(0,0,0,0.08)}input[type=range].focused:focus:not(.active)::-webkit-slider-thumb{-webkit-box-shadow:0 0 0 10px rgba(38,166,154,0.26);box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-moz-range-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)}input[type=range].focused:focus:not(.active)::-ms-thumb{box-shadow:0 0 0 10px rgba(38,166,154,0.26)} 番组计划 这里将是永远的回忆 window.onload = function(){ videos.forEach(function(video, i){ $('#rootRow').append(` ${video.title} ${video.jp} ${video.status} ${video.title} ${video.jp} 放送时间: ${video.time} ${video.desc} ${video.status} `) }) }"}],"posts":[{"title":"成长日记","slug":"成长日记","date":"2023-02-13T06:23:17.000Z","updated":"2023-02-15T03:32:29.723Z","comments":true,"path":"2023/02/13/成长日记/","link":"","permalink":"http://localhost:4000/2023/02/13/%E6%88%90%E9%95%BF%E6%97%A5%E8%AE%B0/","excerpt":"","text":"2023年2月13日恍如隔世啊，这么快就转正了，之前一直担心再次被误解了我也不想的，可是为什么这么容易被误解啊，我当时咳嗽一下是真的想咳嗽没啥没啥，没啥没啥，加油加油，只是一件小事做好自己的事情就好了，多学多做今天把博客搞定这个月要把内部正式系统用Vue3写一部分，以及高分04星调度系统前端添加目标点，单步测试 2023年2月15日我已经转正了，绩效申报也过了，之前一直担心的事情就这么消失地无影无踪了我的日记不在了，怎么也找不到，每个月都有月报，要写总结我的专注度一直在下滑，要收拾心情好好工作","categories":[],"tags":[]},{"title":"TypeScript","slug":"TypeScript","date":"2023-01-17T01:57:26.000Z","updated":"2023-01-30T03:40:43.373Z","comments":true,"path":"2023/01/17/TypeScript/","link":"","permalink":"http://localhost:4000/2023/01/17/TypeScript/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"react学习","slug":"react学习","date":"2023-01-06T02:56:07.000Z","updated":"2023-01-06T06:48:42.619Z","comments":true,"path":"2023/01/06/react学习/","link":"","permalink":"http://localhost:4000/2023/01/06/react%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"在学习react的过程中，对Vue理解更深刻，并且也学到部分JavaScript知识DOM元素绑定函数的时候，如果函数带括号并添加参数，可能使得DOM元素绑定的函数只是函数的返回值，也就是说，函数带括号和参数会在初始阶段直接被调用，并且将返回值赋给元素的绑定函数，导致DOM元素绑定函数失效。总结就是，DOM绑定函数，一定要返回的是函数，无所谓是否带参数，这是JavaScript中的一个点","categories":[],"tags":[]},{"title":"Vue前端部署","slug":"Vue前端部署","date":"2023-01-05T10:08:28.000Z","updated":"2023-01-10T02:42:52.247Z","comments":true,"path":"2023/01/05/Vue前端部署/","link":"","permalink":"http://localhost:4000/2023/01/05/Vue%E5%89%8D%E7%AB%AF%E9%83%A8%E7%BD%B2/","excerpt":"","text":"使用 npm run build打包，产生dist文件，但是直接打开dist文件的index.html为空白，并且浏览器控制台报错 在vue.config.js文件中添加： publicPath : ‘.&#x2F;‘, assetsDir : ‘static’, parallel : false,重新build,打开index.html，成功，但是遇到跨域问题。 原因在于打包后你在代码中配置的proxyTable不会被打包入dist文件中。所以要找一个外部的插件解决跨域问题。可以使用nginx 本地运行Vue可以使用express服务器 外网可以直接全局安装serve,express等npm包，内网只能使用nginx解决跨域问题 外网使用serve无法解决跨域问题 npm install package -g 其中-g写在后面才是全局安装 搭建了express服务器，依然不能解决跨域问题 serve包和express包应该是一类的，跨域问题需要自行解决 安装了cors包并使用还是没解决跨域问题，使用http-proxy-middleware查到的基本都是nginx解决跨域问题 vue.config.js publicPath应为’.&#x2F;‘而非’&#x2F;‘，后者打不开index.html 使用nginx一直没成功终于解决了 有的攻略详解是有问题的，nginx配置文件都写得有问题https://blog.csdn.net/qq_44450612/article/details/110082170 在内网配置时相当简单，几行配置代码就搞定了","categories":[],"tags":[]},{"title":"答辩资料","slug":"答辩资料","date":"2022-12-09T03:44:14.000Z","updated":"2023-01-13T03:28:43.586Z","comments":true,"path":"2022/12/09/答辩资料/","link":"","permalink":"http://localhost:4000/2022/12/09/%E7%AD%94%E8%BE%A9%E8%B5%84%E6%96%99/","excerpt":"","text":"CGI-&gt;JSP&#x2F;ASP-&gt;MPA-&gt;SPA MPA和JSP&#x2F;ASP概念并非冲突的反而早期都是MPA，SPA是慢慢成型的 只需要介绍SPA的概念即可，没必要从CGI开始介绍，本来的内容，包括了前后端分离的优势，SPA的优势，Vue的优势，东西太多无从下手 精简一下，先介绍总体是Vue2+Spring boot前后端分离架构，然后前端使用Vue+Leaflet+OpenStreetMap，接下来是Vue的优势以及使用了Leaflet这个JavaScript库作为地图容器，OpenStreetMap作为地图瓦片图层（科室内已有地图瓦片的相关服务） 服务器只需要给出数据，而不是整个HTML文本，渲染完成的DOM CGI通用网关接口，实现客户端浏览器与服务器之间数据的交互 Vue-cli Vue-Router Vuex vuex使用场景： 当一个组件需要多次派发事件时。例如购物车数量加减。跨组件共享数据、跨页面共享数据。例如订单状态更新。需要持久化的数据。例如登录后用户的信息。当您需要开发中大型应用，适合复杂的多模块多页面的数据交互，考虑如何更好地在组件外部管理状态时 JSP&#x2F;ASP 增强了 WEB 与服务端的交互的安全性，其实就是Java + HTMLJSP有一个很大的缺点，就是不太灵活，因为JSP是在服务器端执行的，通常返回该客户端的就是一个HTML文本。我们每次的请求：获取的数据、内容的加载，都是服务器为我们返回渲染完成之后的 DOM，这也就使得我们开发网站的灵活度大打折扣 多页面应用由多个完整页面构成，跳转刷新所有资源，每个页面资源不共用，页面切换加载慢，流畅度不够，用户体验比较差，维护成本高，适用于追求高度支持搜索引擎的应用，以及一些非常大型的，页面初始化资源消耗量高的应用 单页面应用适用于高要求的体验度、追求界面流畅的应用 最开始使用CGI通用网关接口+实现客户端浏览器与服务器之间数据的简单通信，只能实现静态页面JSP&#x2F;ASP在服务器端渲染DOM，返回给客户端完整的HTML文本，灵活度很低 先简单介绍一下SPA的优势，然后重点介绍使用的技术栈以及其优势。直接介绍技术栈，再介绍技术栈的优势，然后是常用于PC端官网之类的。 SPA常用于PC端官网购物等网站 单页面应用缺点1，不利于seo 2，导航不可用，如果一定要导航需要自行实现前进、后退。（由于是单页面不能用浏览器的前进后退功能，所以需要自己建立堆栈管理） 3，初次加载时耗时多 4，页面复杂度提高很多 SEO效果差，因为搜索引擎只认识html里的内容，不认识js渲染生成的内容，搜索引擎不识别，也就不会给一个好排名，会导致单页应用做出来的网页在搜索引擎上的排名差。 并不能说后者的出现就完全淘汰了旧有的技术，旧技术在一些特定场景依然有用。 Vue特性Vue组件化开发，视图，数据与结构相分离。 数据更新更为简单，不需要进行逻辑代码的修改，只需要操作数据就能完成相关操作。代码量减少，重构更容易，开发维护更便捷。 组件化开发的优点：提高开发效率、方便重复使用、简化调试步骤、提升整个项目的可维护性、便于协同开发。 数据驱动视图，使用指令系统响应式地双向数据绑定，页面响应式刷新使用虚拟DOM，降低DOM渲染频率，用户体验更流畅单页面应用，跳转无需请求数据，页面局部刷新，降低数据请求频率，加快访问速度丰富的生态系统。 插件库很丰富，比如Vue-Router,Vuex等等，也可以使用很多第三方UI库 Vue使用基于依赖追踪的观察系统并且使用异步队列更新，所有的数据都是独立触发的，提高了数据处理能力。 单页面应用的优势 使用npm包管理器，方便结合各类第三方UI库和JavaScript库 Vue-router懒加载 Vue + Spring boot leaflet+openstreetmap tile瓦片 先介绍技术栈 Vue + Ant Design Vue + Leaflet Ant Design Vue是前端UI框架，Leaflet是地图容器插件 本来使用的高德，但内网只能离线使用换成了Leaflet，地图瓦片使用的OpenStreetMap，在科室里直接提供了相关服务。 使用了npm包管理器离线使用依赖库，使用Vue-Router懒加载 Vue的优势Vue属于单页面应用SPA Vue特性 &#x3D;&gt; 优势 Vue属于SPA，页面 Vue对数据双向绑定，使用虚拟DOM leaflet作为地图容器，OpenStreetMap作为地图瓦片 组件化开发的优点：提高开发效率、方便重复使用、简化调试步骤、提升整个项目的可维护性、便于协同开发。而Virtual DOM则是虚拟DOM的英文，简单来说，他就是一种可以预先通过JavaScript进行各种计算，把最终的DOM操作计算出来并优化，由于这个DOM操作属于预处理操作，并没有真实的操作DOM，所以叫做虚拟DOM。最后在计算完毕才真正将DOM操作提交，将DOM操作变化反映到DOM树上。 Vue的优势，再提一下SPA，以及leaflet和OpenStreetMap&#x2F;GaoDe. npm包管理器？Vue-Router?Vue-router懒加载，加快首屏速度 本系统使用Vue+Spring boot前后端分离架构，前端使用Vue+Ant Design Vue 再介绍结果 高分04星生产调度系统 生产结果功能：数据栏展示，条件检索，锚点定位，日志查看，详细信息和图片展示特点：锚点、数据栏和详细信息栏实时联动响应变化。 视频要展示这些联动变化 正在生产实时刷新正在生产的计划信息生产队列，核心生产信息、计划所有步骤和当前步骤 提交页面和参数配置页面 数据处理前端展示最终成果的代码在2500行左右，这还是去除了制作过程中迭代更新的代码量 高分04星生产调度系统 环境安装 环境配置文档，软件使用说明 对接测试，负责一部分对接任务，以及整体调度系统的测试， 开发更新，负责前端内容的更新 实时刷新日志信息 日志信息也要展示，不能是空白的 前端页面一行一行对比，更新了哪些东西，可以在开始强调工作量 还有后端代码也可以说一下，更新了控制层代码，也就是前后端的接口部分，用于展示一些之前没有的东西，比如详细信息 最终结果核心代码从1200左右到2700行左右，不是简单的继承，只保留了一部分需求代码，其余的都删除更改。并且结果核心代码也没有包括数次迭代更新的代码，比如修补bug，更新展示效果，精简代码使之更流畅更难出错等等。中间几个版本很多时候靠forceUpdate来刷新页面 Vue2 不响应数据软更新 正在生产要实现产品锚点闪烁 要更新meta文件详细内容和地图的联系，在预答辩之后更改 对应关系不对其实图像产品对应的一景，不是一个schedulePlan。点击schedulePlan，产生出来的一个详细信息，只是一个meta文件的信息，一景的信息，但是一个schedulePlan不止生产一景。 必须首先声明，meta文件图像产品是编造出来用于展示的，一个schedulePlan只展示其对应的tranplan的一景 可以将生产结果改为ImagePlan信息或者在详细信息栏，多级信息，一个transplanId下多个imagePlan，第二级有多个imagePlan，一个scheduleId展示 定位日志检索把日志加上 生产结果页面也更新了一部分后端控制层代码正在生产页面主要更新了后端控制层代码任务提交页面也更新了一部分后端控制层代码，+任务提交页面在这之前是不能提交任务的，更新以后可以提交了 前端，提交提示，表单验证 参与了前期一部分的对接，以及调度系统的整体测试，产品生产步骤的单步测试和全流程测试 对接测试包括 数据库安装，系统文件权限检查更新，算法处理步骤更新，配置文件更新，处理结果和日志对比，调度系统更新 这个提交页面，其实没有完成功能，无论是表单验证还是前后端接口对接维护升级GF04星生产调度系统 修改JL1GF04B_SC.sh和JL1GF04B_Quality.sh文件 Vue打包后基本只能使用nginx解决跨域问题 未来 本岗位的目的和作用，系统开发？前端开发？ 根据卫星图像产品生产的一般流程技术体系，系统软件开发在其中起到了实时对接生产任务需求，串联生产步骤，分配计算资源的作用，以及后台展示产品信息，生产状态 高级生产数据处理是卫星应用综合管理系统的一部分 高分04星生产调度系统的重要性，这个项目是公司在国外比较重要的一笔订单，","categories":[],"tags":[]},{"title":"Vue+leaflet","slug":"Vue-leaflet","date":"2022-11-24T10:38:59.000Z","updated":"2022-12-09T03:44:44.412Z","comments":true,"path":"2022/11/24/Vue-leaflet/","link":"","permalink":"http://localhost:4000/2022/11/24/Vue-leaflet/","excerpt":"","text":"leaflet只是加载个地图容器，还需要瓦片 下载离线地图使用先把容器搭建出来，再去寻找可用的离线瓦片地图 可以先使用在线的瓦片地图 vue2-leafleafhttps://www.jianshu.com/p/c55375e2b0a2 离线使用瓦片https://www.cnblogs.com/RainyBear/p/6011832.html 要实现setFitView函数invalidateSize 可以直接使用fitBounds函数fitBounds 必须设置maxBounds 求出多个坐标的中心点即可let cenLng &#x3D; (parseFloat(maxLng) + parseFloat(minLng)) &#x2F; 2let cenLat &#x3D; (parseFloat(maxLat) + parseFloat(minLat)) &#x2F; 2https://www.giserdqy.com/secdev/leaflet/17883/ 转储sql文件，导入时发现数据量少了很多 中文乱码问题，编码问题 目前无法进入mysql 发现安装mysql的那几个命令有问题 应该要把数据库删了重建mysql8修改root密码，必须Xiezb@123456 不是安装命令有问题安装命令触发BUG,主要是mysql8不认这么简单的密码，必须重新设置密码 可能是密码出问题了ERROR 1045 (28000): Access denied for user ‘root‘@‘localhost‘ (using password)修改密码后就好了https://blog.csdn.net/dxy1128/article/details/116043330 乱码解决，创建数据的时候，将数据库的character_set全部改为utf8mb4 解决了两个问题，一个是mysql命令，触发了mysql8检查密码，简单密码不可用，root无法登录必须更改，更改的过程，一直没有使用use mysql，也没法更改过来同时设置密码的时候一直错误，后来发现mysql8密码必须大小写数字加特殊字符(例如@)最终更改成功 创建数据库除了当时设置utf8mb4，也必须把所有的character_set设置为utf8mb4最终导入成功 解决这些bug必须了解其原理 计算当前视图中所有元素的中心点 {“mode”:”PD”,”l1_prefix”:”&#x2F;DiskArray&#x2F;GSHC2IMPS&#x2F;PRODUCT&#x2F;2022&#x2F;08&#x2F;25&#x2F;JL1GF04A&#x2F;JL1GF04A_PMS_20220825110646_258666400_101_001_L1_%s&#x2F;JL1GF04A_PMS_20220825110646_258666400_101_%04d_001_L1_%s&#x2F;JL1GF04A_PMS_20220825110646_258666400_101_%04d_001_L1_%s”,”meta_time”:”2022-08-25 11:06:46”,”l0_prefix”:”E:&#x2F;ProductionSchedule&#x2F;mnt&#x2F;sgtest&#x2F;GSHC2IMPS&#x2F;FREDDATA&#x2F;2022&#x2F;08&#x2F;25&#x2F;258666400_JL1GF04A&#x2F;101&#x2F;PMS&#x2F;JL1GF04A_PMS_20220825110646_326612114_101_%04d_001_L0_%s”,”l1_arch”:”&#x2F;DiskArray&#x2F;GSHC2IMPS&#x2F;PRODUCT&#x2F;2022&#x2F;08&#x2F;25&#x2F;JL1GF04A&#x2F;JL1GF04A_PMS_20220825110646_258666400_101_001_L1_%s&#x2F;“,”segment”:”101”,”name”:”U02_20220825_49182MOVE[PD]”,”image_plan_id”:”IMG_TASK_20220825_69990”,”sensor”:”PMS”,”end”:”1”,”begin”:”1”} {“mode”:”PD”,”l1_prefix”:”&#x2F;DiskArray&#x2F;GSHC2IMPS&#x2F;PRODUCT&#x2F;2022&#x2F;08&#x2F;25&#x2F;JL1GF04A&#x2F;JL1GF04A_PMS_20220825110646_258666400_101_001_L1_%s&#x2F;JL1GF04A_PMS_20220825110646_258666400_101_%04d_001_L1_%s&#x2F;JL1GF04A_PMS_20220825110646_258666400_101_%04d_001_L1_%s”,”meta_time”:”2022-08-25 11:06:46”,”l0_prefix”:”E:&#x2F;ProductionSchedule&#x2F;mnt&#x2F;sgtest&#x2F;GSHC2IMPS&#x2F;FREDDATA&#x2F;2022&#x2F;08&#x2F;25&#x2F;258666400_JL1GF04A&#x2F;101&#x2F;PMS&#x2F;JL1GF04A_PMS_20220825110646_326612114_101_%04d_001_L0_%s”,”l1_arch”:”&#x2F;DiskArray&#x2F;GSHC2IMPS&#x2F;PRODUCT&#x2F;2022&#x2F;08&#x2F;25&#x2F;JL1GF04A&#x2F;JL1GF04A_PMS_20220825110646_258666400_101_001_L1_%s&#x2F;“,”segment”:”101”,”name”:”U02_20220825_49182MOVE[PD]”,”image_plan_id”:”IMG_TASK_20220825_69990”,”sensor”:”PMS”,”end”:”1”,”begin”:”1”} {“mode”:”PD”,”l1_prefix”:”&#x2F;DiskArray&#x2F;GSHC2IMPS&#x2F;PRODUCT&#x2F;2022&#x2F;08&#x2F;25&#x2F;JL1GF04A&#x2F;JL1GF04A_PMS_20220825110646_258666400_101_001_L1_%s&#x2F;JL1GF04A_PMS_20220825110646_258666400_101_%04d_001_L1_%s&#x2F;JL1GF04A_PMS_20220825110646_258666400_101_%04d_001_L1_%s”,”meta_time”:”2022-08-25 11:06:46”,”l0_prefix”:”E:&#x2F;ProductionSchedule&#x2F;mnt&#x2F;sgtest&#x2F;GSHC2IMPS&#x2F;FREDDATA&#x2F;2022&#x2F;08&#x2F;25&#x2F;258666400_JL1GF04A&#x2F;101&#x2F;PMS&#x2F;JL1GF04A_PMS_20220825110646_326612114_101_%04d_001_L0_%s”,”l1_arch”:”&#x2F;DiskArray&#x2F;GSHC2IMPS&#x2F;PRODUCT&#x2F;2022&#x2F;08&#x2F;25&#x2F;JL1GF04A&#x2F;JL1GF04A_PMS_20220825110646_258666400_101_001_L1_%s&#x2F;“,”segment”:”101”,”name”:”U02_20220825_49182MOVE[PD]”,”image_plan_id”:”IMG_TASK_20220825_69990”,”sensor”:”PMS”,”end”:”1”,”begin”:”1”} 不一定能贴上图，都没有这些图了 meta文件可能也没有了 {“auxdata”:”&#x2F;DiskArray&#x2F;GSHC2IMPS&#x2F;FREDDATA&#x2F;2021&#x2F;06&#x2F;02&#x2F;200051683_JL102C&#x2F;102&#x2F;PMS1&#x2F;JL102C_200051683_PMS1_102_auxdata.dat”,”meta_time”:”2021-06-01 17:10:43”,”raw”:”&#x2F;DiskArray&#x2F;GSHC2IMPS&#x2F;FREDDATA&#x2F;2021&#x2F;06&#x2F;02&#x2F;200051683_JL102C&#x2F;102&#x2F;PMS1&#x2F;JL102C_200051683_PMS1_102”,”mode”:”IA”,”l1_prefix”:”&#x2F;DiskArray&#x2F;GSHC2IMPS&#x2F;PRODUCT&#x2F;2021&#x2F;06&#x2F;02&#x2F;JL1GP02&#x2F;JL1GP02_PMS1_20210601171043_200051683_102_001_L1&#x2F;JL1GP02_PMS1_20210601171043_200051683_102_%04d_001_L1&#x2F;JL1GP02_PMS1_20210601171043_200051683_102_%04d_001_L1”,”ref”:”&#x2F;DiskArray&#x2F;ProductionSchedule&#x2F;JL1012CRef&#x2F;2021&#x2F;06&#x2F;PMS1&#x2F;JL102C&#x2F;200051683&#x2F;102_B0_1.25.ref”,”product_type”:”DEICC,CATALOG,ORIARCH,DEICC,CATALOG,REF,RC,SC,WB,REGISTRATION,ORIENTATION,RESAMPLE,CREATEVIDEO,BANDMATCH,QUALITY,GEOPRECISION,PRODUCTARCH,UPDATERESULT”,”l0_prefix”:”&#x2F;DiskArray&#x2F;GSHC2IMPS&#x2F;FREDDATA&#x2F;2021&#x2F;06&#x2F;02&#x2F;200051683_JL102C&#x2F;102&#x2F;PMS1&#x2F;JL102C_PMS1_20210601171043_200051683_102_%04d_001_L0”,”l1_arch”:”&#x2F;DiskArray&#x2F;GSHC2IMPS&#x2F;PRODUCT&#x2F;2021&#x2F;06&#x2F;02&#x2F;JL1GP02&#x2F;JL1GP02_PMS1_20210601171043_200051683_102_001_L1&#x2F;“,”segment”:”102”,”name”:”月球推扫0601_B[IA]”,”image_plan_id”:”IMG_TASK_20210531_0155”,”sensor”:”PMS1”,”end”:”1”,”orb_prefix”:”&#x2F;DiskArray&#x2F;GSHC2IMPS&#x2F;FREDDATA&#x2F;2021&#x2F;06&#x2F;02&#x2F;200051683_JL102C&#x2F;102&#x2F;PMS1&#x2F;KSAT1_JL102C_013038_200051683_001_1_PMS1_FRED_20210601171043_102”,”begin”:”1”,”others”:”{&quot;isSensitive&quot;:&quot;0&quot;,&quot;composite&quot;:&quot;false&quot;,&quot;client&quot;:&quot;国家气象局&quot;,&quot;emergency&quot;:&quot;false&quot;}”} 必须删除一些记录 还差队列状态，imageDetail，贴图 还有提交任务 validateField imageOverlayjpg图可以使用imageOverlay，但是很丑 leaflet-geotiff-2队列状态更新已完成还是得加上tif贴图加载tif图出现问题，更换依赖项以后还是出问题 换到leaflet-geotiff还是不行 决定只是用jpg，但是只能贴一轨的图片 使用Leaflet.ImageOverlay.Rotated进行斜放图片，现在可以 npm install 使用–save选项，可以在package.json看到","categories":[],"tags":[]},{"title":"PBS学习","slug":"PBS学习","date":"2022-11-15T02:45:17.000Z","updated":"2022-11-15T08:47:42.651Z","comments":true,"path":"2022/11/15/PBS学习/","link":"","permalink":"http://localhost:4000/2022/11/15/PBS%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"hostnamectl set-hostname host.pbs.cg 设置主机名 cat&lt;&gt;file 输入内容到文件，以EOF结束","categories":[],"tags":[]},{"title":"PBS","slug":"PBS","date":"2022-11-02T06:53:28.000Z","updated":"2023-02-02T00:46:42.245Z","comments":true,"path":"2022/11/02/PBS/","link":"","permalink":"http://localhost:4000/2022/11/02/PBS/","excerpt":"","text":"安装虚拟机，因为之前使用了Hyper-V，但是Hyper-V传递文件相当麻烦，（此处浪费一上午时间，用来给Hyper-V中的虚拟机传递文件） 改用VMware，但是出现冲突，Device&#x2F;Credential Guard不兼容关闭了Hyper-V的服务程序https://blog.csdn.net/vkingnew/article/details/108821617 使用此教程关闭Device&#x2F;Credential Guard https://kb.vmware.com/s/article/2146361 https://blog.csdn.net/li707414287/article/details/119136633 要么蓝屏，要么报错不兼容 似乎是因为我的版本是20H2，无法解决 VMware官网说明Hyper-V和VMware软件不兼容，也看到又说更深层次的原因是20版本之后的windows系统提供了一个内核级别的虚拟化安全性服务。和VMware的虚拟机发生冲突。使用VMware官网介绍的方法关闭Hyper-V以及相关服务，都和虚拟机有关，比如虚拟化的安全性之类的。后来还原的过程中，似乎关闭或开启了什么服务导致目前连接不了 目前内网和光纤网都能ping通，但是无法将华为服务器挂载到Z盘上报错的原因是本地设备名已在使用中。 node环境，Java环境，mysql环境如果需要npm install 就在外网下载，打包好传到内网 Java8环境可能需要重装 电脑本身 在安装监控软件之前，三个网址都能ping通，但是输入hw02.cifs.com无法联通 在安装软件之后，盘阵IP无法ping通，同时发现监控软件是灰色的，可能需要激活 重装系统后没有office sudo service pbs_server start#pbs_server是TORQUE集群中head node的核心守护进程，用于接收用户提交的作业请求，根据pbs_sched进程提供的可用节点资源清单进行作业分发和回收sudo service pbs_sched start#pbs_sched是TORQUE集群中head node的另外一个核心守护进程，用于监控compute node的运行状态，根据pbs_server传递过来的用户作业脚本要求在集群中寻找可用计算节点并反馈给pbs_server进程sudo service pbs_mom startsudo service trqauthd start#trqauthd是TORQUE集群head node和compute node都需要运行的守护进程，用于授权pbs_mom进程与pbs_server进程之间建立互信连接 便捷命令 qterm –t quickfor i in pbs_server pbs_sched pbs_mom trqauthd; do service $i start; done查看论文 基于Torque的异构集群平台调度算法的设计与实现 Torque使用先到先服务策略方法 吞吐率，资源负载均衡，集群能耗问题 作业调度器包括作业调度模块和作业状态监控模块 调度算法 优先级调度 pbs_sched模块实现调度器 集中式调度有缺陷 torque 开源的集群资源和作业管理软件","categories":[],"tags":[]},{"title":"阶段总结","slug":"阶段总结","date":"2022-11-01T08:40:10.000Z","updated":"2023-02-10T02:59:09.150Z","comments":true,"path":"2022/11/01/阶段总结/","link":"","permalink":"http://localhost:4000/2022/11/01/%E9%98%B6%E6%AE%B5%E6%80%BB%E7%BB%93/","excerpt":"","text":"主要是Vue前端页面 解决的问题如下：JS的所有函数都是异步，但是使用promise链又太冗长使用computed属性和watch，解决加载页面时一些初始化函数的同步处理问题。 全局变量问题，加载地图产生的变量，必须使用data中的变量来接收，才可以在全局使用，并且Vue可以实时监视，这个作用在开发过程中反复出现 table和marker的地图位置对应，功能添加。 以及其他的一些小问题，比如drawer和modal的层级问题，滚轮定位，滑入定位,transPlan和schedulePlan 由于selectedRowKeys和marker的大小是绑定的，在这之前都是改变之后进行相应的动作，最后代码优化，使用watch属性 以及Vue和JS的一些知识，Ant design vue的使用，比如a-table的各类属性rowClassName,rowSelection,customRow的使用Vue的watch对于一些引用型数据，仅仅只是简单复制，会造成newValue和oldValue一样，想要实现深度复制后的监视，使用computed属性进行深度复制后，监视深度复制后的数据 接下来的目标添加详细展示每个imagePlan的框一个Vue文件写了太多东西比较乱，部分功能应该使用组件来组合。 ThreadPool一直监测是否有生产计划，如果获取到就创建生产任务线程，标记生产计划队列QueueTask获取生产步骤，转换生产状态 controller-&gt;service-&gt;serviceImpl-&gt;mapper(dao)-&gt;mapper controller 负责具体的业务模块流程的控制。此层要调用Service层的接口去控制业务流程。 service 业务层或服务层，主要负责业务模块的逻辑应用设计。 serviceImpl service的具体实现 DAO(mapper)，DAO&#x3D; Data Acess Object, 数据持久层，对数据库进行持久化操作，负责跟数据库打交道。通常我们在DAO层里写接口，里面有与数据打交道的方法。SQL语句通常写在mapper文件里。 entity就是数据实体，也就是Model-View-Controller中的Model，与数据库中的某个表相关联 template前端页面 controller给出了每个页面的控制方法。 建博客，修改博客然后写每月总结","categories":[],"tags":[]},{"title":"CSS定位","slug":"CSS定位","date":"2022-10-26T03:41:08.000Z","updated":"2022-10-31T03:23:44.600Z","comments":true,"path":"2022/10/26/CSS定位/","link":"","permalink":"http://localhost:4000/2022/10/26/CSS%E5%AE%9A%E4%BD%8D/","excerpt":"","text":"relative,absolute,fixed,sticky grid和flex布局","categories":[],"tags":[]},{"title":"Vue插槽详解","slug":"Vue插槽详解","date":"2022-10-18T09:04:50.000Z","updated":"2022-10-18T09:04:50.996Z","comments":true,"path":"2022/10/18/Vue插槽详解/","link":"","permalink":"http://localhost:4000/2022/10/18/Vue%E6%8F%92%E6%A7%BD%E8%AF%A6%E8%A7%A3/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"JavaScript学习","slug":"JavaScript学习","date":"2022-10-17T06:08:34.000Z","updated":"2022-10-17T06:08:34.257Z","comments":true,"path":"2022/10/17/JavaScript学习/","link":"","permalink":"http://localhost:4000/2022/10/17/JavaScript%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Vue组件通信","slug":"Vue组件通信","date":"2022-10-14T08:49:22.000Z","updated":"2022-10-14T08:49:22.849Z","comments":true,"path":"2022/10/14/Vue组件通信/","link":"","permalink":"http://localhost:4000/2022/10/14/Vue%E7%BB%84%E4%BB%B6%E9%80%9A%E4%BF%A1/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"VScode调试Vue","slug":"VScode调试vue","date":"2022-09-08T00:53:53.000Z","updated":"2022-09-08T08:14:09.969Z","comments":true,"path":"2022/09/08/VScode调试vue/","link":"","permalink":"http://localhost:4000/2022/09/08/VScode%E8%B0%83%E8%AF%95vue/","excerpt":"","text":"在写Vue项目时总是遇到各种奇形怪状的坑https://vue.docschina.org/v2/cookbook/debugging-in-vscode.html这个教程有误，没有npm start命令 使用Vscode调试Vuehttps://vuejs.bootcss.com/cookbook/debugging-in-vscode.html官网教程 https://cli.vuejs.org/zh/config/第一次尝试不成功，可能是是配置项有proxy网络代理，从官网的配置项教程来看，配置项也存在错误配置项也有相应的对象设置等等规范 不启用代理，在 vue.config.js文件中仅设置configureWebpack module.exports &#x3D; { configureWebpack: { devtool: ‘source-map’ }, lintOnSave: false }最终成功以上有误，不启用代理将无法得到数据 也可以直接使用debugger语句","categories":[{"name":"Vue","slug":"Vue","permalink":"http://localhost:4000/categories/Vue/"}],"tags":[]},{"title":"ES的一些新特性","slug":"ES的一些新特性","date":"2022-09-01T01:59:41.000Z","updated":"2022-09-01T02:00:19.043Z","comments":true,"path":"2022/09/01/ES的一些新特性/","link":"","permalink":"http://localhost:4000/2022/09/01/ES%E7%9A%84%E4%B8%80%E4%BA%9B%E6%96%B0%E7%89%B9%E6%80%A7/","excerpt":"","text":"https://juejin.cn/post/6844903811622912014","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://localhost:4000/categories/JavaScript/"}],"tags":[]},{"title":"ES6模块化","slug":"ES6模块化","date":"2022-09-01T01:50:54.000Z","updated":"2022-09-01T08:57:40.868Z","comments":true,"path":"2022/09/01/ES6模块化/","link":"","permalink":"http://localhost:4000/2022/09/01/ES6%E6%A8%A1%E5%9D%97%E5%8C%96/","excerpt":"","text":"https://juejin.cn/post/6864203164418539527 模块化介绍 https://www.runoob.com/w3cnote/es6-module.html 菜鸟教程 https://juejin.cn/post/6844904003722018830 详细总结 https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Modules MDN文档的JavaScript模块介绍 https://juejin.cn/post/6844903811622912014 ES6、ES7、ES8、ES9、ES10新特性一览 ES 6中具有对象、继承、封装等特性方便我们来对一个具体来实现，但是在使用的时候不能像java与C#中具有包或命名空间的模块意识，在使用的时候没有解决引用的方案，因此，ES 6是有一个模块化的方式来提供解决方案。模块化主要由export、import两个命令来规定接口的相关信息和使用方式。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://localhost:4000/categories/JavaScript/"}],"tags":[]},{"title":"JS原型和原型链","slug":"JS原型和原型链","date":"2022-08-31T06:53:00.000Z","updated":"2022-09-01T08:55:42.687Z","comments":true,"path":"2022/08/31/JS原型和原型链/","link":"","permalink":"http://localhost:4000/2022/08/31/JS%E5%8E%9F%E5%9E%8B%E5%92%8C%E5%8E%9F%E5%9E%8B%E9%93%BE/","excerpt":"","text":"Vue大量使用了原型和原型链同时也使用了ES6的模块化 MDN文档https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Inheritance_and_the_prototype_chain function doSomething()&#123;&#125; console.log( doSomething.prototype ); // 和声明函数的方式无关， // JavaScript 中的函数永远有一个默认原型属性。 var doSomething = function()&#123;&#125;; console.log( doSomething.prototype ); JavaScript作为一门动态语言，对象可以视作“一包属性”或者属性的动态集合（可以动态添加减少），被构造函数创建的实例对象的 [[ Prototype ]] （也就是__proto__） 指向 func 的 prototype 属性。**Object.prototype **属性表示 Object 的原型对象。prototype和[[ Prototype ]]属性并不一样。 https://segmentfault.com/a/1190000021232132 这篇博客更加清晰 重要在于__proto__ (在浏览器控制台中显示为 [[ prototype ]] )、prototype、 constructor 三个属性 var Parent = function()&#123; &#125; //定义一个函数，那它只是一个普通的函数，下面我们让这个函数变得不普通 var p1 = new Parent(); //这时这个Parent就不是普通的函数了，它现在是一个构造函数。因为通过new关键字调用了它 //创建了一个Parent构造函数的实例 p1 js中对象和函数的关系，函数其实是对象的一种。函数、构造函数的区别，任何函数都可以作为构造函数，但是并不能将任意函数叫做构造函数，只有当一个函数通过new关键字调用的时候才可以成为构造函数。 1.__proto__、 constructor属性是对象所独有的；2.prototype属性是函数独有的；3.上面说过js中函数也是对象的一种，那么函数同样也有属性__proto__、 constructor； prototype属性可以看成是一块特殊的存储空间，存储了供子孙类使用的方法和属性。 prototype设计之初就是为了实现继承，让由特定函数创建的所有实例共享属性和方法，也可以说是让某一个构造函数实例化的所有对象可以找到公共的方法和属性。有了prototype我们不需要为每一个实例创建重复的属性方法，而是将属性方法创建在构造函数的原型对象上（prototype）。那些不需要共享的才创建在构造函数中。 Parent.prototype.name = &quot;我是原型属性，所有实例都可以读取到我&quot;; _proto__属性相当于通往prototype唯一的路（指针），让实例对象(p1)知道构造函数提供的的共享属性和方法.__proto__通常称为隐式原型，prototype通常称为显式原型，那我们可以说一个对象的隐式原型指向了该对象的构造函数的显式原型。那么我们在显式原型上定义的属性方法，通过隐式原型传递给了构造函数的实例。这样一来实例就能很容易的访问到构造函数原型上的方法和属性了。 p1.__proto__ === Parent.prototype; // true Parent.prototype.__proto__ === Object.prototype; //true 通过输出看到Parent函数的构造函数是Function() console.log(Parent.constructor); // ƒ Function() &#123; [native code] &#125; var fn1 = new Function(&#39;msg&#39;,&#39;alert(msg)&#39;); function fn1(msg)&#123; alert(msg); &#125; console.log(Function.constructor); // ƒ Function() &#123; [native code] &#125; Function函数的构造函数就是本身，Function是所有函数的根构造函数 https://juejin.cn/post/6844903989088092174 1.js分为函数对象和普通对象，每个对象都有__proto__属性，但是只有函数对象才有prototype属性2.Object、Function都是js内置的函数, 类似的还有我们常用到的Array、RegExp、Date、Boolean、Number、String3.属性__proto__是一个对象，它有两个属性，constructor和__proto__；4.原型对象prototype有一个默认的constructor属性，用于记录实例是由哪个构造函数创建； function Person(name, age)&#123; this.name = name; this.age = age; &#125; Person.prototype.motherland = &#39;China&#39; let person01 = new Person(&#39;小明&#39;, 18); 1. Person.prototype.constructor == Person // **准则1：原型对象（即Person.prototype）的constructor指向构造函数本身** 2. person01.__proto__ == Person.prototype // **准则2：实例（即person01）的__proto__和原型对象指向同一个地方** 实例对象重写原型上继承的属相、方法，相当于“属性覆盖、属性屏蔽”，这一操作不会改变原型上的属性、方法，自然也不会改变由统一构造函数创建的其他实例，只有修改原型对象上的属性、方法，才能改变其他实例通过原型链获得的属性、方法。 Javascript中有一句话，叫一切皆是对象，当然这句话也不严谨，比如null和undefined就不是对象，除了这俩完全可以说Javascript一切皆是对象。而Javascript对象都有一个叫做原型的公共属性，属性名是_proto_。这个原型属性是对另一个对象的引用，通过这个原型属性我们就可以访问另一个对象所有的属性和方法。 https://segmentfault.com/a/1190000021787756 在JavaScritp中有7种基础数据string, number, bigint, boolean, undefined, symbol, 和null类型，其中symbol是ES6新加入的，bigint在ES10新增，除了这些数据类型外，其他所有你能看到的，用到得都是Object类型，也就是对象，所有对象都有__proto__访问器属性（getter 和 setter），但是它不是ECMAScript标准所规定的属性，只是历史的产物，在实际开发中，使用Object.getPrototypeOf方法来获取__proto__指向的对象。 var a = [&quot;yo&quot;, &quot;whadup&quot;, &quot;?&quot;]; // 数组都继承于 Array.prototype // (Array.prototype 中包含 indexOf, forEach 等方法) // 原型链如下： // a ---&gt; Array.prototype ---&gt; Object.prototype ---&gt; null function f()&#123; return 2; &#125; // 函数都继承于 Function.prototype // (Function.prototype 中包含 call, bind 等方法) // 原型链如下： // f ---&gt; Function.prototype ---&gt; Object.prototype ---&gt; null 在原型链上查找属性比较耗时，对性能有副作用，这在性能要求苛刻的情况下很重要。另外，试图访问不存在的属性时会遍历整个原型链。 遍历对象的属性时，原型链上的每个可枚举属性都会被枚举出来。要检查对象是否具有自己定义的属性，而不是其原型链上的某个属性，则必须使用所有对象从 Object.prototype 继承的 hasOwnProperty (en-US) 方法。","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://localhost:4000/categories/JavaScript/"}],"tags":[]},{"title":"Vue学习","slug":"Vue学习","date":"2022-08-31T03:12:49.000Z","updated":"2022-11-12T02:14:55.260Z","comments":true,"path":"2022/08/31/Vue学习/","link":"","permalink":"http://localhost:4000/2022/08/31/Vue%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"https://www.bilibili.com/video/BV15741177Eh?p=76&amp;vd_source=e566061f8d6653c807847b31868afa8b https://www.bilibili.com/video/BV1Vf4y1T7bw/?p=2&amp;spm_id_from=pageDriver&amp;vd_source=e566061f8d6653c807847b31868afa8b https://www.bilibili.com/video/BV1Zy4y1K7SH/?spm_id_from=333.788.recommend_more_video.0&amp;vd_source=e566061f8d6653c807847b31868afa8b课程的学习笔记 Vue特性曾经使用纯粹的HTML、CSS和JS文件三者组合写出一个界面，前后端传递数据极不方便以及Springboot框架结合Thymeleaf模板引擎写表单页面，以及后端的表单处理程序，前端程序需要写JS代码，使用Jquery操作DOM 采用组件化模式，声明式编码（而非命令式编码） 具体详情可以查资料，总之使得前端编写更加方便，具体事务由框架做出，程序员只需要声明即可，数值传递等常用的动作由框架实现Vue使用虚拟DOM,DIFF算法动态刷新 (这实现了动态刷新) favicon.ico是页签图标live server插件挺好用 Vue实例想让vue工作，必须创建一个vue实例，且要传入一个配置对象，这个配置对象可以配置多个参数 Vue.config.productionTip = false Vue.prototype.axios = axios new Vue(&#123; router, store, render: h =&gt; h(App) &#125;).$mount(&#39;#app&#39;) new Vue(&#123; el:&#39;root&#39;, data:&#123; &#125; methods:&#123; &#125; &#125;) 以上代码用到了原型，以及Vue实例，挂载在app容器里，开发中只有一个Vue实例，并且配合着组件一起使用，Vue()是构造函数，具有prototype Vue模板语法包含插值语法和指令语法，插值语法用于解析标签体内容，指令语法用于解析标签（包括：标签属性、标签体内容、绑定事件…）Vue插值语法 用来传值,xxx使用js表达式 Vue指令语法包含 v-bind,v-if,v-model 等等，同样使用JS表达式 v-bind实现单项绑定，数据流从data流向页面,v-bind:简写为:v-model实现数据双向绑定（data&lt;&#x3D;&gt;页面），使得数据回显很方便，但是只能应用在表单类（输入类）元素上，这类元素具有value属性v-model:value可以简写为v-model，因为默认收集的就是value值 &lt;script type=&quot;text/javascript&quot;&gt; const v = new Vue(&#123;&#125;) console.log(v) &lt;/script&gt; 我们可以在浏览器中观察v实例，以及其构造器Vue 带$符号的便是提供给开发者的方法，部分方法可在 [[ prototype ]]中找到，这涉及到了原型和原型链最常见的便是 v.$mount(‘#app’) 不带$符号的是Vue运作的底层方法 以函数式返回data对象时，其函数的this必须是Vue实例，箭头函数的this是window MVVM模型M 模型(Model):对应data中的数据V 视图(View): 模板VM 视图模型(ViewModel): Vue实例对象 data所有的属性都附在VM上，而VM(Vue实例对象)所有的属性以及Vue原型上的属性在Vue模板中都可以直接使用 Vue的数据代理Object.defineProperty方法在Vue的数据劫持、数据代理和计算属性都用到了这个方法，它可以实现通过一个对象代理对另一个对象中属性的操作(读&#x2F;写)这个方法的getter做到了实时读取，也就是浏览器控制台的(…)，当点击读取时，触发get函数，获得实时数据setter做到了数据实时传递，get和set一起使用实现了数据的双向绑定V-bind绑定后的数据，是可以解析的JS表达式 Vue实例的_data属性提取了options.data属性，并且自身创建相应数据属性，与_data实现双向绑定（数据代理） Vue事件处理学习事件对象eventevent.target.innerText等等 JS的事件流分为捕获阶段和冒泡阶段 Vue键盘事件 每个键盘按键都有名字，比如Enter,CapsLock，但是得用caps-lockalt键特殊，必须配合keydown使用,meta键是徽标键修饰符(stop,prevent之类的)可以连续写 Vue计算属性每当data属性发生变化，Vue会重新解析一遍模板，所有用到数据的地方都要更改可以用插值语法和methods实现computed，举个栗子，Vue实例会解析插值语法中的函数和表达式demo()并返回经过加工后的属性，其实插值语法是可以解析表达式的，但是Vue官方并不推荐这种风格，插值语法中尽可能清晰简单所谓的计算属性，就是去计算加工出一个全新的属性，底层使用的是Object.defineProperty方法，Vue实例自行调用计算属性有缓存，而methods属性没有缓存 computed:&#123; fullname:&#123; get()&#123; return **** &#125; set()&#123; &#125; &#125; &#125; 当计算属性不需要设置set时（只考虑读取不考虑修改），可以采用简写形式 computed:&#123; fullname()&#123; return **** &#125; &#125; Vue监视属性Vue管理的data,computed,methods等等，其this均为Vue实例(ViewModel)，模板中也是从这些属性中寻找，所以不需要添加this,同时例如alert之类的，window下的方法，不能直接调用 watch:&#123; property:&#123; immediate:true, deep:true, handler(newvalue,oldvalue)&#123; &#125; &#125; &#125; 属性没带’ ‘实际上是简写 当配置项只有handler时开启简写 watch:&#123; property(newvalue,oldvalue)&#123; &#125; &#125; 计算属性不能开启异步任务 一般来讲，computed，methods等等中的函数，都是Vue管理的函数，其this被设定为vm，组件实例对象，而这些函数中的函数，如果不是箭头函数，其this变为window Vue绑定样式 绑定style同样也有对象写法和数组写法，但是用得不多 Vue渲染按住alt就能选中多行 Vue key作用与原理 列表过滤和列表排序自查 Vue监测数据的原理Vue底层用JS代码完整地实现了数据监视，不止是简单地调用Object.defineProperty 所有不是由Vue控制的回调尽可能用箭头函数 数据劫持的含义就是，Vue对data中的数据处理过程，添加getter,setter等等，这使得Vue能够完成数据监视 Vue收集表单数据Vue过滤器Vue _ref属性用于代替 document.getElementByID()，给标签添加ref属性后，this.$refs会有标签DOM可以用于寻找Vue组件实例对象在用于一般的HTML标签时，和ID属性没什么区别，在用于Vue组件时会有区别,ref属性能找到Vue的实例对象，但是ID找到的是Vue的整个DOM结构 v-text指令 v-html指令v-cloak指令v-once指令v-pre指令自定义指令mixin混入 Vue props属性复用组件时，模板一致，数据不一致，可以使用props一个组件使用另一个基础组件，并传入相应的数据，基础组件可以限定接收的数据类型要注意v-bind能够解析JS表达式，可以将 age:”18” 变成 :age:”18”,解析后传入数值而非字符串props属性可以使用required限定必须传过来的数据，使用default设置默认值使用props接收数据后尽可能不要直接修改（容易报错），可以通过data和methods加工后使用props属性优先级比data属性高 Vue生命周期用debugger调试前端代码图片在四十九节 mounted意味着初始化完成，并且完成挂载和渲染，重要函数，自定义初始化函数在此处编写，比如启动定时器，发送ajax请求，绑定自定义事件订阅消息等等而beforeDestroy函数相应地完成清除定时器，解绑取消等操作 https://juejin.cn/post/6874855535234170887 Vue 脚手架Vue CLI Vue 脚手架隐藏了所有webpack相关的配置，若想查看具体，命令执行 : vue inspect &gt; output.js在Vue CLI官网配置参考出现的属性可以更改，在Vue.config.js文件中，配置项使用node规范（因为要和webpack合并） Vue组件分别暴露，统一暴露，默认暴露babel可以做到ES6转换到ES5eslint做语法检查 引入Vue只是引入了vue.runtime.es.js，没有模板解析器，所以使用render函数用于解析webpack可以帮我们把vue文件打包为html,css,js文件，在使用场景，不再需要vue的模板解析器Vue包含核心和模板解析器（模板解析器占三分之一），引入时使用精简版本，并使用render函数作为解析渲染方式 组件中的template使用vue-template-compiler模块解析 Vue.use()使用插件，插件本质上是一个对象 Vue在解析各个组件的style样式会汇总在一起，那么名字相同会起冲突，最终样式以引入顺序最后一个为准，使用scoped可以限定在组件范围内这种方法为每个组件的div设定了唯一的ID Vue插槽，是组件本身有一个空置的地方（插槽），组件的使用者在使用组件时，可以在组件标签中填充一些内容，从而使得插槽被填充并显示，填充内容由使用者自行选择插槽的作用是让父组件可以向子组件指定位置插入html结构，也是一种组件间通信的方式，适用于父组件&#x3D;&#x3D;&#x3D;&gt;子组件 具名插槽可以使得组件使用者为指定插槽填充内容（当有多个插槽时）当插件使用者使用template作为插槽的填充内容时，可以使用v-slot指定插槽 当插件使用者使用插件，填充插件中的slot时，其数据来源于插件而非使用者（使用者需要定义数据的使用方式，定义数据的生成结构），使用作用域插槽，被使用的插件在插槽上声明数据，那么使用者就能得到这个数据。使用者需要用以下方式获得数据 浏览器本地存储LocalStorage 手动清除消失sessionStorage 随着浏览器存储关闭而消失 JSON.stringify()能够将对象转换为字符串形式并且能看到内容JSON.parse()将字符串解析为对象 浏览器上的黑色为字符串，蓝色是数字 Vuex专门在Vue中实现集中式状态（数据）管理的一个Vue插件1.多个组件依赖同一状态2.来自不同组件的行为需要变更同一状态 Vue-routervue的一个插件库，专门用来实现spa应用（single page web application） spa应用1.单页web应用2.整个应用只有一个完整的页面3.点击页面中的导航链接不会刷新页面，只会做页面的局部更新4.数据需要通过ajax请求获取 路由分为后端路由和前端路由 全局事件总线 任意组件间通信Vue配置代理前后端之间的通信方式xhr new XMLHttpRequest() xhr.open() xhr.send() 最底层,JS内置，window对象下具有这个底层对象jQuery $.get $.post 很重，核心80%都是封装DOM操作，20%是周边操作，封装了xhraxios promise风格 封装xhrfetch promise风格 和xhr一个级别，有兼容性问题，包装了两层promise，同样是window的内置对象 跨域问题请求从浏览器发出，到达服务器，服务器响应，浏览器接收发现跨域，不交付数据同源策略：协议名，主机名，端口号必须一致 后端cors可以实质上的解决跨域问题jsonp可以比较巧妙地解决跨域问题，利用script中的src不受跨域影响的特性，但是需要前后端一起做，并且只能解决get请求，相对比较少见 代理服务器，通过服务器之间的通信，避开了同源策略的限制使用nginx可以开启代理服务器vue-cli也可以做到，使用devServer配置 https://blog.csdn.net/abraham_ly/article/details/114400117https://zhuanlan.zhihu.com/p/104984869 举个栗子，Vue前端使用 http://localhost:8080http是协议，localhost是主机，8080是端口，前端使用了这个地址的服务器而后端使用的是 http://localhost:5000 那么两者不同源，无法资源交互 无法读取非同源网页的 Cookie、LocalStorage 和 IndexedDB无法接触非同源网页的 DOM无法向非同源地址发送 Ajax 请求 vue-cli使用devServer.proxy开启代理服务器 Vue-cli下的public文件夹是根目录pathRewrite是重写路径，避免把api之类的开头放入请求url中ws: true &#x2F;&#x2F;用于支持websocket，客户端和服务端的一种通信方式changeOrigin 用于控制请求头中的host值 https://vue3js.cn/interview/ 一些Vue的知识点有很多DOM函数，DOM操作需要学习 getBoundingClientRect()获取元素的wraper的盒子DOMRect对象，有表示大小和位置的属性。 Element.scrollTop属性可以设置滚动条垂直滚动的像素scrollBy,scrollTo 可以尝试使用watch属性来判定数据项选择，marker产生以及大小问题 Vue watch只是简单赋值，对于引用类型指向同一个地址，所以使用computed进行深度赋值 强制重新渲染的四种方式：https://www.cnblogs.com/YiFeng-Liu/p/14835986.html this.$router.go(0) v-if vm.$forceUpdate() 仅仅渲染实例本身和插入插槽内容的子组件，而不是所有子组件。 key-changing 对于对象，使用vue-$set()添加新属性。","categories":[{"name":"Vue","slug":"Vue","permalink":"http://localhost:4000/categories/Vue/"}],"tags":[]},{"title":"vue前端使用高德地图","slug":"Vue前端使用高德地图","date":"2022-08-31T02:31:53.000Z","updated":"2022-12-01T01:25:58.367Z","comments":true,"path":"2022/08/31/Vue前端使用高德地图/","link":"","permalink":"http://localhost:4000/2022/08/31/Vue%E5%89%8D%E7%AB%AF%E4%BD%BF%E7%94%A8%E9%AB%98%E5%BE%B7%E5%9C%B0%E5%9B%BE/","excerpt":"","text":"vue项目结合高德地图 首先在高德地图官网申请key,本项目使用web端https://console.amap.com/dev/key/app 官方web地图开发文档https://lbs.amap.com/api/jsapi-v2/guide/abc/prepare 最简单的方式，使用javascript脚本添加，(JSAPI因为webpack版本原因无法下载loader) https://www.bilibili.com/video/BV1U44y1W77D?p=29&amp;vd_source=e566061f8d6653c807847b31868afa8b这个视频用最简单的方式使用了高德地图 http://vue-gaode.rxshc.com/ 原生高德API的一个教程 https://zhuanlan.zhihu.com/p/102882843 介绍饿了么将高德地图封装成的一个npm包，用于vue开发 https://juejin.cn/post/6920103004259500045 高德地图API的一个引入使用总结 在public文件夹下的index.html文件中添加 也就引入了高德地图组件 地图需要一个div作为容器 &lt;template&gt; &lt;div id = &quot;container&quot; style=&quot;width: 100% height: 100%&quot;&gt;&lt;/div&gt; &lt;/template&gt; 地图组件需要挂载在mounted下 mounted() &#123; var map = new AMap.Map(&quot;container&quot;, &#123; zoom: 13, // center: [116.473195,39.973253], // resizeEnable: true, // mapStyle: &#39;amap://styles/whitesmoke&#39; &#125;) var marker = new Amap.marker(&#123; position: new Amap.LngLat(116.39, 39.9), title: &#39;北京&#39; &#125;); map.add(marker); &#125;, 在路由上挂载了这个map.vue页面，运行后产生一个地图，同时页面中央是北京 1.在 HTML 里引入 JS 外链文件的做法和 Vue 工具链中常见的引入&#x2F;构建方式（如 webpack）不太搭调2.需要在 Vue 组件的 mounted() 里通过 $refs 拿到容器 DOM 元素，再去创建地图，再在 Vue 组件 beforeDestroyed() 里销毁刚才创建的地图3.当你更新了数据时，需要手工调用地图、地图元素的各种 set 方法来同步修改它们的属性 尝试使用JSAPI，npm i @amap&#x2F;amap-jsapi-loader –save 命令报错，似乎是webpack版本有误可能需要重新搭建，升级webpack Vue CLI使用的webpack版本是4.46，而地图的NPM使用方式需要webpack5版本以上，无法使用，只能使用官网JS脚本添加最终找到原因，原项目中Less-loader版本过高，降低到7以后安装成功本项目是一个单页面web，通过路由跳转到相应的组件 信息窗体太受限了，其content不好编写，如何结合后端数据实时展示也是个问题可以设置点标注的文本标签以及文字提示，信息窗体的content也许可以使用ref属性（得到Vue实例的dom对象）和props属性（给Vue实例传递数据信息）来个性化，写起来的麻烦程度不亚于直接描述content，这个方案以后再考虑 可以先使用ant-design-vue模板来写，可以绑定标记点的信息，先尝试使用气泡卡片来展示内容，用抽屉展示总体信息 a-popover和marker不好结合，并非固定位置，先尝试使用，如果不行，就使用抽屉或者通知框显示最后再尝试使用V-for列表渲染div，props结合组件展示信息 使用最简单的方式检查发现气泡展示在最上方正中央，并且发现内容实时展示也不好结合后端数据，只有单个气泡卡片，要展示所有的锚点数据也是很困难的 实在不能实现气泡展示就放弃，他们的页面也都没有气泡展示 鼠标移入（或者聚焦），气泡展示简略信息，点击后，以抽屉形式显示详细信息 marker.on(&#39;mouseover&#39;, this.markerHover); marker.emit(&#39;mouseover&#39;, &#123; target: marker &#125;); marker.on(&#39;click&#39;, this.markerClick); marker.emit(&#39;click&#39;, &#123; target: marker &#125;); 当为标记点同时添加了mouseover和click事件时，打开map页面，无法渲染锚点 在测试时发现是marker的title和content出现矛盾，去掉content后可以渲染锚点，并且鼠标移入时会出现title 在删除示例中的emit动作以后，出现以下报错并且无法显示点标记锚点[Violation] Added non-passive event listener to a scroll-blocking ‘touchstart’ event. Consider marking event handler as ‘passive’ to make the page more responsive. See https://www.chromestatus.com/feature/5745543795965952将非被动事件侦听器添加到滚动块“touchmove”事件。考虑将事件处理程序标记为“被动”，以提高页面的响应速度 从字面意义上看似乎是这两个事件放到一个元素上有矛盾 [Violation] ‘requestAnimationFrame’ handler 用时 毫秒 高德的emit函数 emit(type, data) 模拟触发当前实例的某个事件 参数说明： type (String) 事件类型 data (Object) 事件回调时返回的数据，模拟的事件体应该完整，否则可能导致报错 返回值： Object: 当前实例 在示例中有emit函数时，打开页面便触发了该函数的事件，因此必须去掉emit。当没有去掉时，不会有上述报错 最终发现marker.title可以自动实现鼠标滑过展现内容上述报警并不影响最终结果经过测试发现在官网demo中 for (var i &#x3D; 0, marker; i &lt; lnglats.length; i++) { var marker &#x3D; new AMap.Marker({ position: lnglats[i], map: map }); marker.content &#x3D; ‘我是第’ + (i + 1) + ‘个Marker’;如果将上述改为 for (var i &#x3D; 0, marker; i &lt; lnglats.length; i++) { var marker &#x3D; new AMap.Marker({ position: lnglats[i], map: map, content: ‘我是第’ + (i + 1) + ‘个Marker’ });content会覆盖锚点，也就是锚点样子变成content的文字内容也就是说，在new的时候添加content和new之后添加会有不一样的效果，也就是官网的’content有效时，icon属性将被覆盖。’ this.resData = Object.assign([], this.imageData).map((item) =&gt; &#123; return Object.assign(&#123;&#125;, item); &#125;); 如何将对象转变为JSON对象关于 object.assign()简书 Object.assign()的使用MDN Object.assign() JSON.parse(JSON.stringify())是深拷贝，而object.assign()是浅拷贝 谷歌浏览器控制台查看对象属性，深色的属性就是可枚举属性，浅色的属性就是不可枚举属性。 简书 JavaScript的map()函数 电脑在重启以后，无法实现点击锚点弹出抽屉框 &#x2F;&#x2F; marker.on(‘mouseover’, this.markerHover()); &#x2F;&#x2F; marker.emit(‘mouseover’, { target: marker }); marker.on(‘click’, this.markerClick(i)); marker.emit(‘click’, { target: marker });最开始是可以的，甚至于content覆盖icon的时候，点击也能弹出抽屉框，可能又要考虑promise链了以及，在删除掉emit函数以后，打开页面不会自动打开抽屉框。但是现在没有emit函数，页面也会自动打开抽屉框 再次重启以后还是同样的问题，点击锚点无反应猜测是在mounted阶段的marker，在这之后无法使用 但是很奇怪的是，官网demo，使用marker.on()，并不会触发emit事件，并且，点击锚点有反应猜测原因是，Vue实例渲染后，在VC实例下找不到marker 测试官方demo，最开始 .then((AMap) &#x3D;&gt; { this.map &#x3D; new AMap.Map(“container”, { viewMode: “3D”, zoom: 5, zooms: [2, 22], resizeEnable: true, center: [105.602725, 37.076636], }); 删除上述初始化map的代码时发现可以用了，并且删除emit函数同样不会触发，点击也有效 将代码全部放到mounted()中，奇怪的是，demo代码在初始化阶段不会触发点击，同时手动点击也有效但我的代码会在初始阶段触发点击，手动点击无效 当我把markerClick()函数放在mounted中，不会触发点击，手动点击有效，但是将infoWindow挂载在this下，this.infoWindow找不到setContent() 主要问题是，demo不会在初始阶段点击，但是我的代码总是要在初始化阶段点击触发函数，两者区别仅仅是我的代码使用axios获取数据以后，在.then中初始化marker甚至于，demo并不需要 map.add(marker)就能渲染出marker 总结就是，Vue代码和官方的JSAPI代码有点不兼容我在axios.then中将marker添加到this.markerlist中，拿出来的list没有on函数同理，之前的this.infoWindow找不到setContent也是因为将元素放置到this下后丢失了一部分属性 点击后没有效果可能也是Vue找不到该元素下的方法 最终解决了这个问题，竟然是绑定点击函数时出现了问题，item.on(‘click’,function)不能给function带括号，但是带了括号却自动触发了函数以及需要在data属性中添加对应字段并设为null或者’’空字符串，这样Vue组件能将其设为全局变量 search框放到一个子组件中 可以使用props，父组件使用map组件，子组件接收marker要用的数据并使用 iconfont 阿里巴巴矢量图标库 翻页就重新渲染锚点点击锚点定位定位列表中的相应数据项，点击数据项中的定位操作，画面中心为相应锚点 根据id无法直接获取对应的计划或者图像信息，两个数据表数据都对不上的 没必要那么多锚点，我只要默认选择第一个计划的所有图就可以了，并且可以把中心设为这些图的中央然后默认锚点选择了第一个计划 做不到后台管理系统的那样，能够加上一整页schedulePlan的锚点，因为schedulePlan没有经纬度信息，需要获取imagePlan，但是获取imagePlan是异步的，很难做到获取多组imagePlan并且添加锚点。要实现这套，初始化所有schedulePlan的image锚点，翻页更新所有锚点。后台管理系统使用image做到的。 当用户取消了默认计划，锚点消失，选择另一个计划，添加锚点要实现点击计划，产生锚点，取消计划，取消锚点，必须记录锚点列表 可以使用rowSelections来指定锚点对应行 解构赋值gengerator可以把异步变成同步可以理解对象的原型是个匿名对象。构造函数首字母应当大写，而普通函数首字母应当小写let声明的变量不会成为全局对象window的属性，var可以 没有name属性的input数据不会被表单提交 出于安全考虑，浏览器无法获得本地文件的真实路径toggle()方法切换显示和隐藏，相应的还有fadeToggle,slideToggle 点击锚点，抽屉不要自动关闭，可以使用row-selection来实现背景颜色按照教程使用rowClassName修改table某一行背景颜色不成功 ant design vue 的customRow,rowSelection,rowClassName用customRow使得鼠标移入，已存在的相应marker变化（增大）marker颜色无法使用style.color改变，marker的style里面没有颜色属性可以通过筛选，点击marker筛选出想要的数据行 style scoped慎用，容易导致CSS设置样式不生效，style scoped设置组件样式私有，不污染全局样式。 翻页时锚点应该删掉 使用rowClassName实现隔行换色样式未生效，查看元素发现class已设置但是未生效可以把抽屉设置成半透明 发现是颜色设置有问题，必须用rgb，十六进制设置不生效，后来验证十六进制也可以，很奇怪最终使用rowClassName实现了表格行背景颜色改变 可以设置让用户自己增大抽屉 阮一峰的网络日志 https://www.ruanyifeng.com/blog/ 在template的属性值里面使用十六进制 设置抽屉样式成功，但是无论是wrapStyle还是drawerStyle都无法达到想要的结果，先将就着用 设置初始marker的size变小，在靠近或者点击marker以后增大（暂时先这样，以后可以改变颜色，但是）并且相应的数据项变背景底色，再次点击marker变小，数据项颜色消失。点击锚点后选择了相应的数据项 锚点名字应该是任务名+经纬度，点击数据项以后，应该有个可以展开伸缩隐藏的框，框里有多个栏目，显示当前选择了哪些数据项，每个数据项下有多个锚点，以及相应的imageplan数据，在略过这些数据和锚点时，相应的锚点会增大，每个数据栏都可以叉掉，叉掉的同时，锚点消失，schedule锚点展示标换成普通颜色 经过一个锚点，其一组锚点都会增大，相应的数据栏会变底色。略过后变小，点击锚点后，选择了其一组的schedulePlan，并且在imageplan上添加了这一组数据，被选中的锚点其图标会变颜色，同时其数据栏底变色。 两个scheduleId可以对应同一个transPlanId一个transPlanId对应了很多schedulePlanId和imagePlanId 添加一个scheudleId对应的marker，可能把另一个scheduleId的marker也添加了，因为两者对应了同一个transPlanId,对应了同一组imagePlanID，对应了同一组marker 再次添加同一组marker时，这组marker变大变小闪烁一下。 下个版本将页面简化，分成多个组件，使用组件通信。nextTick 无法改变选中行的背景颜色，查看demo，应该是rowSelection指定了选中行的背景颜色，当选中后又取消，背景颜色换成自己指定的颜色 querySelector有效，但是document.getElementsByClassName却没有效果，拿不到dom因为getElementsByClassName返回数组，需要索引取元素，并且类名不能加. 因为本身参数就是取类名而querySelector参数是CSS选择器结构，所以类名要加. 在列表中选中数据行不需要滚动定位，滚动定位需要使用scroll属性，并且，滚动只针对table本身的scroll，其wrap，也就是抽屉的Body，如果有滚动条，并不会发生改变。也就是必须保证，wrap没有滚动栏。最终使用screen的高度来设置table的scroll高度，保证抽屉没有滚动条 定位滚动设置完毕 使用rowClassName设置背景颜色不成功，似乎和rowSelection默认背景颜色冲突如果没有经纬度，可能报错导致无法把marker添加到各类列表中去，要处理出现没有经纬度，报错于是不能添加marker到列表中的情况 光标靠近锚点，同组锚点增大，离开，锚点变小，点击，锚点维持大小 JavaScript有多个缺省值，但是只想输入其中几个怎么做 设置marker大小，图标一部分没法显示，imageOffset这个属性有毒，不能用发现setFitView还是有问题使用bottom-center后，标签变大正常了，底部不会改变位置 setTimeOut,setInterval在点击location，并且此scheduleId对应的transPlan已经在地图上出现了，那么其marker组应该尺寸渐变 mouseOut和click出现冲突，点击后应该大小维持不变，可以使用hover，或者使用一个全局变量来控制，当前的target是否已经被点击，如果被点击就不会触发 点击marker不应该触发数据抽屉，否则太频繁了正在生产的计划应该闪烁定位后的setFitView仅仅只需要针对刚刚出现的marker 还需要加筛选条件以及imagePlan按钮 schedule不应该用抽屉，image也最好不要用抽屉，抽屉对于实时定位和滚轮定位太不方便了 a-modal和a-drawer出现冲突，需要将a-modal的级别提高 可以将操作放在最右边，然后抽屉可以通过按钮拉长，但是rowSelection在左边勾选 高级检索要添加条件 Vue点击按钮添加一个card组件实际上可以把Views里的文件简化，使用组件。 使用v-for添加组件 customRow的实时性，尝试使用类似selectedRowKeys的方式，但是总是报错 不需把列表单个元素数据给组件，只需要在组件中渲染出列表来，两种方法都可以试 schedulePlan选择有上限 选择计划以后，无法setFitView这个计划 可以先不用组件，用V-for渲染即可，也就是v-for和a-list,a-card结合，展示详细信息 详细信息包括meta中的数据 把抽屉列表中的信息删除一部分，放到框中。 要设定高德地图放大和缩小的上下限 visibility 要删除DOM，所以会比较慢，尽量使用display 详细信息使用meta文件一个schedule可能对应了几个meta文件 可以使用z-index属性改变覆盖物层级 不清楚是覆盖物层级原因还是a-list的data-source无法实时响应数据，也可能跟v-for的渲染原理有关,应该是最大原因就是V-for无法实时响应数据变化，这是V-for的一个坑。其实总结就是，无法响应Array,Map,Set变化，原理还是浅拷贝。最终使用this.$forceUpdate()可以正常更新，这个函数真好用！ 设置z-index无效，对于ant-design等模板，要设置z-index可能需要穿透 mouseenter在点击以后，也是没办法做到立即回应，（尝试修改过最终放弃），最终发现也是无法对Map类型的数据进行实时追踪更新。Vue不能监视Map或者Set数据的变化，原因和List一样。 Map有三种迭代器对象keys() 拿到一个迭代器对象，由键组成values() 由值组成的迭代器对象entries() 键值对数组组成的迭代器对象但是在V-for中，如果使用v-for &#x3D; “(value,key) in map”，默认使用entries迭代器对象v-for遍历一个map，v-for &#x3D; “(value,key) in map”key值并非map中的key值，而是index值，value[0]才是key值，而value[1]才是真正的value值 scheduleMarkerMap也要监视响应变化。暂时使用forceUpdate来更新mapforceUpdate更新有点慢，如果快速点击多个数据行，可能会产生BUG 可以通过computed监视Map 可以将scheduleMarkerMap也修改为computed操作 {“auxdata”:”&#x2F;DiskArray&#x2F;GSHC2IMPS&#x2F;FREDDATA&#x2F;2019&#x2F;05&#x2F;29&#x2F;200013831_JL106B&#x2F;101&#x2F;PMS2&#x2F;200013831_PMS2_101_auxdata.dat”,”meta_time”:”2019-05-28 16:22:48”,”mode”:”LPB”,”l1_prefix”:”&#x2F;DiskArray&#x2F;GSHC2IMPS&#x2F;PRODUCT&#x2F;2019&#x2F;05&#x2F;29&#x2F;JL106B&#x2F;JL106B_PMS2_20190528162248_200013831_101_001_L1_%s&#x2F;JL106B_PMS2_20190528162248_200013831_101_%04d_001_L1_%s&#x2F;JL106B_PMS2_20190528162248_200013831_101_%04d_001_L1_%s”,”l0_prefix”:”&#x2F;DiskArray&#x2F;GSHC2IMPS&#x2F;FREDDATA&#x2F;2019&#x2F;05&#x2F;29&#x2F;200013831_JL106B&#x2F;101&#x2F;PMS2&#x2F;JL106B_PMS2_20190528162248_200013831_101_%04d_001_L0_%s”,”l1_arch”:”&#x2F;DiskArray&#x2F;GSHC2IMPS&#x2F;PRODUCT&#x2F;2019&#x2F;05&#x2F;29&#x2F;JL106B&#x2F;JL106B_PMS2_20190528162248_200013831_101_001_L1_%s&#x2F;“,”segment”:”101”,”name”:”阿什哈巴德[LPB]”,”image_plan_id”:”IMG_TASK_20190527_0082”,”sensor”:”PMS2”,”end”:”8”,”orb_prefix”:”&#x2F;DiskArray&#x2F;GSHC2IMPS&#x2F;FREDDATA&#x2F;2019&#x2F;05&#x2F;29&#x2F;200013831_JL106B&#x2F;101&#x2F;PMS2&#x2F;KSC_JL106B_008351_200013831_001_1_PMS-1_FRED_20190528162248_101”,”begin”:”1”,”others”:”{&quot;isSensitive&quot;:&quot;0&quot;,&quot;client&quot;:&quot;&quot;,&quot;deliveryType&quot;:&quot;STANDARD_PRODUCT_L1&quot;,&quot;gain&quot;:&quot;0x02-0x01&quot;,&quot;emergency&quot;:&quot;False&quot;}”} 总结每种productlevel的最终生产步骤，并且每种最终生产步骤的meta文件修改了什么直接写个函数，根据productlevel拿到最终的meta文件路径有些没有写出meta文件路径，把 .tif改成_meta.xml文件 先使用一个函数拿到固定文件夹 找到每种productlevel的meta文件 拿到ProductSteps数组的最后一个，再switch，不同情况下的文件在哪里 和盘阵文件对不上，不知道对不对 应该需要添加检索功能 imageDetail展示完整的详细信息，如果要查看图片再添加功能Vue使用forceUpdate更新比较慢，按快了页面反应不过来，或者更新时只针对最后一个动作。 应该做成卡片的样子，然后编排一下，卡片应该可以收缩。描述列表太丑了 直接给object添加属性，可能该属性无法得到监控，但是如果只是展示，并不会改变，那么就不会出问题。抽屉有问题，会覆盖标题，覆盖掉画面的一整个部分 强行设置抽屉样式高度有问题,设置父元素,使其渲染在当前dom 提交页面和参数页面加一个炫酷的背景 PCI公司的GXL生产状态，当前步骤 应该给详细信息添加一些指向，也就是这个信息是哪个可以给a-list添加一些动作，slot为actions或者extra 详细信息是否使用折叠面板？ 注意v-for中的value和key分别是什么，value[0]和value[1]分别是map的键列和值列，这样做是为了多次使用v-for 应该使得Map文件中的Dom为顶栏下方，onSubmit函数 应该可以去掉a-list，只使用a-description v-for无法响应数据的实时更新 Vue能响应数组通过push等方法的更新，但是不能响应通过索引直接赋值，改变数组长度这两类的变化 Vue不能响应Map和Set的变化 两种解决方式，将Map全部修改为数组 第二种 使用mapChangeTracker，但是在实践过程中，发现单纯返回一个不用的数据完全没有用 forceUpdate没什么大用，反而容易卡 scheduleMarkerMap和detailData都是Map selectedRowKeys应该和detailData同步，但是当有一次selectedRowKeys去掉一个scheduleId而detailData没有跟着删掉时，此后再也删不了了 可以通过v-if来刷新子组件，当v-if的值变化时，组件会被重新渲染一遍。 使用key-change重新渲染组件，组件都有key，当key变化时，重新渲染组件。 可能仅仅是无法响应delete这个方法 JavaScript的Map将数据放在Entries这个属性下，V-for也是从中读取数据 是detailData就没有改变，set时能够实时添加，但是delete没有实时删除。 forceUpdate有用，是因为删除的时候不能够找到数据$set和$delete没有用，因为不会放在Object中的entries，设置的时候直接放在外面的属性列上了。 使用Map和Object渲染结果不同，换了取值方式也不行 location的逻辑需要修正，但是不知道数据库的情况部分数据没有位置信息 当多个scheduleId共享同一个transplanId时,mouseenter和mouseleave 数据库里面一定有多个scheduleId对应同一个transplanId，详细信息的location，list的location，以及list的mouse事件需要重新定义逻辑 详细信息中的定位仅仅只是定位，如果没有就不显示，也许可以使用v-if来渲染这个定位 在ant table的mouseenter事件中，发现死循环渲染，在进入数据行的时候，未点击location，不显示定位，当进入数据行，然后点击location,就会出现死循环。可以尝试使用computed，先处理再循环，最后使用比较简单的方式，watch监听this.scheduleId就好了，但是似乎没有响应selectedRowKeys的变化，需要观察scheduleId和selectedRowKeys的联动 在点击的一瞬间,deepSelectedRowKeys并不会变化，只有离开了当前数据行，selectedRowKeys才会刷新，最终使用watch属性完成功能。 自动定位以后可以闪一下，确定刚才被选中的列。 可以使用v-if 和 v-show，但是本项目使用@-webkit-keyframes完成闪烁功能也可以使用animate.css blur事件 Vue的$refs 可能有重生产的Modal检索表单改造完毕 但是似乎除了第一页，后面的数据都无法获得imgaeList，等测试的时候再改吧 正在生产只要生产状态的检索 可以给Marker添加右键点击 doubleClick和click冲突 获得的当前步骤，是所有生产队列中的步骤，并不能直接获得当前生产计划的生产步骤 日志必须换成实时生产日志，实时更新生产日志详细内容是实时生产日志加所有步骤生产日志不能手动刷新，必须自行刷新 一种方案是，点击schedule数据行，在详细内容会获得所有的步骤，根据是否在生产队列中，判定当前步骤。同时加上实时刷新的日志 还有一种方案是，详细信息只有日志（那这样为什么不在数据栏中直接看到呢，或者直接点击日志查看），然后专门有个按钮呈现当前队列的生产步骤这种方案应该被替换为，不再有详细信息栏，而是只有一个数据表，并且加上一个能够显示当前生产队列的Modal最后选择这种。 还有一种方案，详细信息只有步骤，日志在modal呈现。 选择数据项应有额外的操作，只能在测试中做 satellite应该要改 应该可以重复添加addClass 无法在断网情况下使用高德地图","categories":[{"name":"vue","slug":"vue","permalink":"http://localhost:4000/categories/vue/"}],"tags":[]},{"title":"Java依赖注入和控制反转","slug":"Java依赖注入和控制反转","date":"2022-08-29T01:17:14.000Z","updated":"2022-08-30T01:45:51.253Z","comments":true,"path":"2022/08/29/Java依赖注入和控制反转/","link":"","permalink":"http://localhost:4000/2022/08/29/Java%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E5%92%8C%E6%8E%A7%E5%88%B6%E5%8F%8D%E8%BD%AC/","excerpt":"","text":"这一点很重要，是基础概念 https://www.liaoxuefeng.com/wiki/1252599548343744/1282381977747489 https://juejin.cn/post/6844903907861364750 https://www.jianshu.com/p/506dcd94d4f9 https://segmentfault.com/a/1190000022420504 简单来说，就是控制权反转，程序自身不创建其的依赖对象，而是被动接收，由外部注入。这也就是Spring框架的核心理念之一。Spring框架负责创建组件，根据依赖关系装配组件，按照正确顺序销毁组件，也就是说，程序的控制流程不再由开发者完全控制，而是Spring的IOC容器。IOC容器的作用：将组件的创建+配置与组件的使用相分离，并且，由IoC容器负责管理组件的生命周期。 依赖注入可以通过set()方法实现。但依赖注入也可以通过构造方法实现。 1）控制反转是一种在软件工程中解耦合的思想，把控制权交给了第三方，在运行的时候由第三方决定将具体的依赖对象“注入”到调用类的对象中。2）依赖注入可以作为控制反转的一种实现方式，将实例变量传入到一个对象中去。3）通过 IoC 框架，类 A 依赖类 B 的强耦合关系可以在运行时通过容器建立，也就是说把创建 B 实例的工作移交给容器，类 A 只管使用就可以。","categories":[{"name":"Java","slug":"Java","permalink":"http://localhost:4000/categories/Java/"}],"tags":[]},{"title":"Java注解","slug":"Java注解","date":"2022-08-27T03:40:42.000Z","updated":"2022-08-27T03:40:42.734Z","comments":true,"path":"2022/08/27/Java注解/","link":"","permalink":"http://localhost:4000/2022/08/27/Java%E6%B3%A8%E8%A7%A3/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"js,jq实现按钮选择文件并显示在文本框","slug":"js-jq实现按钮选择文件并显示在文本框","date":"2022-08-26T07:02:16.000Z","updated":"2022-09-27T08:47:06.247Z","comments":true,"path":"2022/08/26/js-jq实现按钮选择文件并显示在文本框/","link":"","permalink":"http://localhost:4000/2022/08/26/js-jq%E5%AE%9E%E7%8E%B0%E6%8C%89%E9%92%AE%E9%80%89%E6%8B%A9%E6%96%87%E4%BB%B6%E5%B9%B6%E6%98%BE%E7%A4%BA%E5%9C%A8%E6%96%87%E6%9C%AC%E6%A1%86/","excerpt":"","text":"这个功能很久都没有实现，几乎查到的所有网上教程都是错的 https://blog.csdn.net/baidu_39298625/article/details/106189630 这个方法总体而言是，点击按钮，实时产生一个不可视的input-file，并且点击， 也许是JS版本问题,查看IDEA的JavaScript版本，为ECMAScript 5.1，无法使用let,可能也没有箭头函数，更改为ECMAScript6 版本即常见的从ES5规范到ES6规范 ECMAscript和JavaScript的关系https://zhuanlan.zhihu.com/p/69171948https://zhuanlan.zhihu.com/p/373086344 JavaScript实现包含三个方面 1. ECMAscript(语言核心功能基于ES规范) 2. DOM— js需要支持对DOM的维护,通过document,element对象实现.这些都是在ES中没有的. 3. BOM— js需要支持对BOM的维护,通过window对象实现.这些都是在ES中没有的. 关于webkitRelativePathhttps://developer.mozilla.org/zh-CN/docs/Web/API/File/webkitRelativePath lay ui 和 semantic ui, element ui 类似 报 post 403错误，并且后端无法打断点调试，使用console.log，发现甚至无法进入函数体中 403（禁止）状态码表明服务端已经明白请求，但是拒绝授权...如果请求中提供了授权的身份认证，服务端认为它们不足以授予访问权限。 很离谱的错误，我甚至无法定位原因，只能猜测是浏览器认定没有权限选择文件 https://blog.csdn.net/qq_45455554/article/details/119024078在解决这个问题的时候，这篇博客代表了大部门答案的逻辑，就是用Button引起一个type为file的input按钮的点击，但是实际测试无效果input-file 设置 Style &#x3D; “display: none “ 或者 “visibility:hidden”还是报403错误？之前不是这种错误，之前是无法显示到文本框中可能需要搜寻一些IDEA调试前端代码的资料 有可能是表单类型的原因，现在要上传文件了 实际上可能是版本原因，也不知道什么原因，甚至连 checkbox中的 onclick &#x3D; “return false;”都无法完成预定功能，无论是JS写法还是jquery写法。 这已经是第二次，网上查到的资料无法实现预定功能","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://localhost:4000/categories/JavaScript/"}],"tags":[]},{"title":"Java反射机制","slug":"Java反射机制","date":"2022-08-26T05:45:50.000Z","updated":"2022-08-30T07:37:07.176Z","comments":true,"path":"2022/08/26/Java反射机制/","link":"","permalink":"http://localhost:4000/2022/08/26/Java%E5%8F%8D%E5%B0%84%E6%9C%BA%E5%88%B6/","excerpt":"","text":"https://blog.csdn.net/javazejian/article/details/70768369 Class 类反射机制允许我们在运行时发现和使用类型的信息,在Java中用来表示运行时类型信息的对应类就是Class类，Class类也是一个实实在在的类，存在于JDK的java.lang包中。 编译时，每一个自定义类，都有对应的Class对象，并且该对象保存在同名.class文件里（编译后的字节码文件保存的就是Class对象），，当我们new一个新对象或者引用静态成员变量时，Java虚拟机(JVM)中的类加载器子系统会将对应Class对象加载到JVM中，然后JVM再根据这个类型信息相关的Class对象创建我们需要实例对象或者提供静态变量的引用值。需要特别注意的是，手动编写的每个class类，无论创建多少个实例对象，在JVM中都只有一个Class对象，即在内存中每个类有且只有一个相对应的Class对象。 Class类只存私有构造函数，因此对应Class对象只能有JVM创建和加载，Class类的对象作用是运行时提供或获得某个对象的类型信息，这点对于反射技术很重要。 获取Class类获取Class对象引用的方式3种，通过继承自Object类的getClass方法，Class类的静态方法forName以及字面常量的方式”.class”。 其中实例类的getClass方法和Class类的静态方法forName都将会触发类的初始化阶段，而字面常量获取Class对象的方式则不会触发初始化。 初始化是类加载的最后一个阶段，也就是说完成这个阶段后类也就加载到内存中(Class对象在加载阶段已被创建)，此时可以对类进行各种必要的操作了（如new对象，调用静态成员等），注意在这个阶段，才真正开始执行类中定义的Java程序代码或者字节码。 使用泛型可以约束声明指定类型的对象，而Class&lt;?&gt;优于直接使用Class，extends关键字可以告知编译器接收某个类型的子类 Class&lt;? extends Number&gt; clazz = Integer.class; clazz = double.class; clazz = Number.class; 向Class引用添加泛型约束仅仅是为了提供编译期类型的检查从而避免将错误延续到运行时期。 可以使用利用Class对象的cast方法进行类型强制转换instanceof 和 isInstance 用于判定对象类型是否正确 反射机制 反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个对象，都能够调用它的任意一个方法和属性，这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。 Constructor类存在于反射包(java.lang.reflect)中，反映的是Class 对象所表示的类的构造方法。 Field 提供有关类或接口的单个字段的信息，以及对它的动态访问权限。反射的字段可能是一个类（静态）字段或实例字段。 Method 提供关于类或接口上单独某个方法（以及如何访问该方法）的信息，所反映的方法可能是类方法或实例方法（包括抽象方法）。 以上三者，都可以通过Class类的方法获得其对象 在Java的java.lang.reflect包中存在着一个可以动态操作数组的类，Array，它提供了动态创建和访问 Java 数组的方法。Array 允许在执行 get 或 set 操作进行取值和赋值。","categories":[{"name":"Java","slug":"Java","permalink":"http://localhost:4000/categories/Java/"}],"tags":[]},{"title":"ConcurrentLinkedQueue和ThreadPoolExecutor","slug":"ConcurrentLinkedQueue和ThreadPoolExecutor","date":"2022-08-26T01:56:08.000Z","updated":"2022-08-30T07:36:10.033Z","comments":true,"path":"2022/08/26/ConcurrentLinkedQueue和ThreadPoolExecutor/","link":"","permalink":"http://localhost:4000/2022/08/26/ConcurrentLinkedQueue%E5%92%8CThreadPoolExecutor/","excerpt":"","text":"ConcurrentLinkedQueuehttps://blog.csdn.net/qq_38293564/article/details/80798310 https://www.pdai.tech/md/java/thread/java-thread-x-juc-collection-ConcurrentLinkedQueue.html#poll%E5%87%BD%E6%95%B0 线程安全的队列实现方式有两种，阻塞算法和非阻塞算法，使用阻塞算法的队列可以用一个锁（入队和出队用同一把锁）或两个锁（入队和出队用不同的锁）等方式来实现，而非阻塞的实现方式则可以使用循环CAS的方式来实现。 ConcurerntLinkedQueue以非阻塞方式实现 ConcurerntLinkedQueue一个基于链接节点的无界线程安全队列。此队列按照 FIFO(先进先出)原则对元素进行排序。队列的头部是队列中时间最长的元素。队列的尾部 是队列中时间最短的元素。新的元素插入到队列的尾部，队列获取操作从队列头部获得元素。当多个线程共享访问一个公共 collection 时，ConcurrentLinkedQueue是一个恰当的选择。此队列不允许使用null元素 ConcurrentLinkedQueue的数据结构与LinkedBlockingQueue的数据结构相同，都是使用的链表结构，包含一个头节点和一个尾节点 内部类Node private static class Node{ … }Node类表示链表结点，用于存放元素，包含item域和next域，item域表示元素，next域表示下一个结点，其利用反射机制和CAS机制来更新item域和next域，保证原子性。 类属性中包含了head域和tail域，表示链表的头节点和尾结点，同时，ConcurrentLinkedQueue也使用了反射机制和CAS机制来更新头节点和尾结点，保证原子性。 offer()函数用于将指定元素插入此队列的尾部 poll()函数用于获取并移除此队列的头，如果此队列为空，则返回null remove()函数用于从队列中移除指定元素的单个实例(如果存在)。其中，会调用到first函数和succ函数 size()函数用于返回ConcurrenLinkedQueue的大小，从第一个存活的结点(first)开始，往后遍历链表，当结点的item域不为null时，增加计数，之后返回大小。 线程不会因为ConcurrentLinkedQueue队列为空而等待，而是直接返回null，所以当实现队列不空时，等待时，则需要用户自己实现等待逻辑。详细查看https://www.pdai.tech/md/java/thread/java-thread-x-juc-collection-ConcurrentLinkedQueue.html#poll%E5%87%BD%E6%95%B0 ThreadPoolExecutorhttps://www.jianshu.com/p/c41e942bcd64https://www.jianshu.com/p/f030aa5d7a28https://www.twle.cn/c/yufei/javatm/javatm-basic-thread-pool2.html concurrent包 java.util.concurrent.locks.ReentrantLock","categories":[{"name":"Java","slug":"Java","permalink":"http://localhost:4000/categories/Java/"}],"tags":[]},{"title":"项目流程","slug":"项目流程","date":"2022-08-25T08:16:29.000Z","updated":"2022-08-25T08:16:29.418Z","comments":true,"path":"2022/08/25/项目流程/","link":"","permalink":"http://localhost:4000/2022/08/25/%E9%A1%B9%E7%9B%AE%E6%B5%81%E7%A8%8B/","excerpt":"","text":"","categories":[],"tags":[]},{"title":"Java的File类和Path类","slug":"Java的File类和Path类","date":"2022-08-25T01:42:18.000Z","updated":"2022-08-26T05:40:34.690Z","comments":true,"path":"2022/08/25/Java的File类和Path类/","link":"","permalink":"http://localhost:4000/2022/08/25/Java%E7%9A%84File%E7%B1%BB%E5%92%8CPath%E7%B1%BB/","excerpt":"","text":"https://www.cnblogs.com/zimug/p/13594066.htmlhttps://blog.csdn.net/qq_40230179/article/details/89430807https://blog.csdn.net/a2013126370/article/details/80966463 Using java.io.File Class Using java.io.FileOutputStream Class Using java.nio.file.Files from NIOJava IO的一些知识 Java传统的IO API种使用java.io.File类中的file.mkdir()和file.mkdirs()方法创建文件夹 mkdirs可以创建两级文件夹，而mkdir必须保证父文件夹存在，创建过程统一返回boolean结果，不会说明原因 https://blog.csdn.net/www_wangjun/article/details/71344589 new File(“”)和 new File(“.”), new File(“.\\“) Java.io.File.listFiles()返回子文件夹,可以使用过滤器 public File[] listFiles() public File[] listFiles(FilenameFilter f) public File[] listFiles(FileFilter f) 为了解决传统IO创建文件夹中异常失败处理问题不明确的问题，在Java的NIO中进行了改进。 Files.createDirectory(path)和Files.createDirectorys(path)，NIO的API创建的文件夹返回值是Path。 https://blog.csdn.net/zwt0909/article/details/51327440 创建文件路径标记，可以用相对路径或者绝对路径，相对路径是基于当前项目文件的路径 https://blog.csdn.net/u010889616/article/details/52694061 从Java 7开始，IO有了新的类,以取代Java.io.File类 import java.nio.file.DirectoryStream; import java.nio.file.FileSystem; import java.nio.file.FileSystems; import java.nio.file.Files; import java.nio.file.Path; import java.nio.file.Paths; import java.nio.file.attribute.FileAttribute; import java.nio.file.attribute.PosixFilePermission; import java.nio.file.attribute.PosixFilePermissions;这些工具类实现了IO File,Path和URI之间的转换 File file &#x3D; new File(“C:&#x2F;my.ini”); Path p1 &#x3D; file.toPath(); p1.toFile(); file.toURI(); Path和Paths类实现了路径管理https://blog.csdn.net/weixin_38569499/article/details/84988087 tif文件格式 以后用到再补充写文件方法","categories":[{"name":"Java","slug":"Java","permalink":"http://localhost:4000/categories/Java/"}],"tags":[{"name":"Java IO","slug":"Java-IO","permalink":"http://localhost:4000/tags/Java-IO/"}]},{"title":"IDEA使用教程","slug":"IDEA使用教程","date":"2022-08-24T10:50:30.000Z","updated":"2022-08-29T03:12:04.304Z","comments":true,"path":"2022/08/24/IDEA使用教程/","link":"","permalink":"http://localhost:4000/2022/08/24/IDEA%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/","excerpt":"","text":"IDEA调试代码http://www.justdojava.com/2019/07/20/debug-in-idea/ https://segmentfault.com/a/1190000039187075 https://www.cnblogs.com/chiangchou/p/idea-debug.html https://segmentfault.com/a/1190000039187075 step over 单步调试代码，直接调用方法返回结果，快捷键F8step into 进入方法内，查看如何返回结果，不过默认情情况下并不会进入 java.* 等类的方法中。如果需要进入，可以在 Setting-Stepping 中设置,排除即可 快捷键F7step out 快速执行方法并返回调用处 Shift+F8 Setp Out Of Code Block 快速跳出循环代码块（未找到） 条件断点 多线程断点暂时用不到，以后更新 Drop Frame 可以回退调试程序，字面意思为丢栈。JVM 中使用栈帧用于进行方法调用数据结构，每次方法调用，对应着一个栈帧在虚拟机中从入栈到出栈的过程。调用方法之后，该方法栈帧将会位于栈顶。使用的时候，将会回退到该方法调用那一行，状态是还未调用时。和Step out的区别是，Step out 将直接返回调用结果，不再在方法内继续往下走 https://blog.51cto.com/ios9/3245769 IDEA教程 https://mp.weixin.qq.com/s?__biz=MzI0MTUwOTgyOQ==&amp;mid=2247492482&amp;idx=1&amp;sn=79fbb525cf5fd5212010a880035ed0d8&amp;scene=21#wechat_redirect IDEA发展历程 https://guobinhit.github.io/intellij-idea-tutorial/https://github.com/judasn/IntelliJ-IDEA-Tutorial 这两个教程比较详细https://blog.51cto.com/ios9/3245769https://juejin.cn/post/6844904020780253191#heading-5https://codeantenna.com/a/KLNaeuPEa3 查一查IDEA教程并补充,可以设置背景图片,也可以补充VScode资料","categories":[{"name":"Java","slug":"Java","permalink":"http://localhost:4000/categories/Java/"}],"tags":[{"name":"IDE","slug":"IDE","permalink":"http://localhost:4000/tags/IDE/"}]},{"title":"Java数组","slug":"Java数组","date":"2022-08-24T05:50:51.000Z","updated":"2022-08-26T01:34:03.692Z","comments":true,"path":"2022/08/24/Java数组/","link":"","permalink":"http://localhost:4000/2022/08/24/Java%E6%95%B0%E7%BB%84/","excerpt":"","text":"ArrayList,List,String[],Arrayhttps://blog.csdn.net/wiidi/article/details/82662965 https://blog.csdn.net/niceyoo/article/details/103097173 https://blog.csdn.net/qq_42002500/article/details/111088801 https://blog.csdn.net/weixin_38278993/article/details/104316623 List是一个接口类，不能创建实例对象，但是可以为List接口创建一个指向自己的对象引用。而ArrayList实现类的实例对象就在这充当指向List接口的对象引用。 List&lt;String&gt; list = new ArrayList&lt;&gt;(); List有两个重要的实现类：ArrayList和LinkedList string[]数组里面是存放string型的值，List是存放string类型的对象，String[]是数组，定长，不可变,List 是泛型 ，非定长，可变如果不能确定数组长度，或者在计算值时需要不断向中间插入一个字符串，可以使用List，生成完成后再用ToArray()方法转换为string[]， String[]也可以通过List的AddRange方法添加到List。 String[]转List：List list &#x3D; Arrays.asList(arr);List转String[]： String[] arr &#x3D; list.toArray(new String[ list.size() ]); asList 方法的参数必须是对象或者对象数组，而原生数据类型不是对象——这也正是包装类出现的一个主要原因。当传入一个原生数据类型数组时，asList 的真正得到的参数就不是数组中的元素，而是数组对象本身！此时List 的唯一元素就是这个数组。原生数据类型包括了int,short,long等。 public class Test &#123; public static void main(String[] args) &#123; int[] myArray = &#123; 1, 2, 3 &#125;; List myList = Arrays.asList(myArray); System.out.println(myList.size()); &#125; &#125; 此代码输出1，而非3。如果尝试遍历 myList ，你会发现得到的元素不是1、2、3中的任意一个，而是一个带有 hashCode 的对象。asList方法: public static List asList(T… a) 注意：参数类型是 T ，根据官方文档的描述，T 是数组元素的 class。如果你对反射技术比较了解的话，那么 class 的含义想必是不言自明。我们知道任何类型的对象都有一个 class 属性，这个属性代表了这个类型本身。原生数据类型，比如 int，short，long等，是没有这个属性的，具有 class 属性的是它们所对应的包装类 Integer，Short，Long。因此，这个错误产生的原因可解释为：asList 方法的参数必须是对象或者对象数组，而原生数据类型不是对象——这也正是包装类出现的一个主要原因。当传入一个原生数据类型数组时，asList 的真正得到的参数就不是数组中的元素，而是数组对象本身！此时List 的唯一元素就是这个数组。 解决方法，使用包装类数组 public class Test { public static void main(String[] args) { Integer[] myArray &#x3D; { 1, 2, 3 }; List myList &#x3D; Arrays.asList(myArray); System.out.println(myList.size()); } } asList ArrayList 和 List&lt;&gt; https://blog.csdn.net/guo0820/article/details/51030526 Arrays 是一个工具类，有sort,binarySearch,ktoString,aslist等方法 https://blog.csdn.net/guo0820/article/details/51030526","categories":[{"name":"Java","slug":"Java","permalink":"http://localhost:4000/categories/Java/"}],"tags":[]},{"title":"postman使用教程","slug":"postman使用教程","date":"2022-08-17T07:53:22.000Z","updated":"2022-08-24T05:46:16.227Z","comments":true,"path":"2022/08/17/postman使用教程/","link":"","permalink":"http://localhost:4000/2022/08/17/postman%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/","excerpt":"","text":"https://www.toutiao.com/article/6913538714060800515/ https://www.toutiao.com/article/6915675572198851075/ https://www.toutiao.com/article/6916875259136475661/ https://www.toutiao.com/article/6828203166245323275/ https://www.toutiao.com/article/6830616186628080132/ 不同类型的接口请求要注意Content-Type上传文件的表单请求需要用到multipart&#x2F;form-data 在测试一些接口时，总是需要登录，因为cookie未设置按照 https://blog.csdn.net/qq_45047809/article/details/116299139 的方式来改变cookie，可是请求总是自动产生cookie 可以取消自动产生cookie或者设置全局cookiehttps://www.csdn.net/tags/MtTaMg1sMzkwODE0LWJsb2cO0O0O.htmlhttps://www.dounaite.com/article/625605bd3351efabace82ae4.html 算了 我前后端都在做，其实postman没那么必要","categories":[{"name":"Java","slug":"Java","permalink":"http://localhost:4000/categories/Java/"}],"tags":[]},{"title":"前后端通信","slug":"前后端通信","date":"2022-08-17T06:31:50.000Z","updated":"2022-10-08T07:43:24.751Z","comments":true,"path":"2022/08/17/前后端通信/","link":"","permalink":"http://localhost:4000/2022/08/17/%E5%89%8D%E5%90%8E%E7%AB%AF%E9%80%9A%E4%BF%A1/","excerpt":"","text":"一部分知识总结 https://developer.mozilla.org/zh-CN/docs/Learn/Forms/Sending_and_retrieving_form_data表单提交的一些基础知识 针对某一场景需求，实现方式又杂又多地原因是，最基础的有DOM，而Javascript语法可以更方便的调用DOM，Jquery又加了一层封装以更简便 哪怕是最基础的通信，从最底层的XMLHttpRequest对象到ajax,Javascript的一些通信方式，以及Jquery的ajaxForm(),ajaxSubmit()等函数封装，到更上层的axios，有很多种方式。对于Form表单的提交，文件的提交，也有底层和上层实现方式。 https://www.w3cschool.cn/ajax/ajax-uy1r2or1.html XMLHttpRequest 是 AJAX 的基础。 XMLHttpRequest 术语缩写为XHR，中文可以解释为可扩展超文本传输请求。XMLHttpRequest 对象可以在不向服务器提交整个页面的情况下，实现局部更新网页。XMLHttpRequest的对象用于客户端和服务器之间的异步通信。 可以新建一个XMLHttpRequest对象实例，并且打开通信 var req = new XMLHttpRequest(); req.open(&quot;post&quot;, &quot;/url&quot;, false); req.send(data); ajax对此进行了封装 前端使用ajax提交表单数据进行通信，当没有返回结果的时候，可以直接使用$(‘#formid’).submit() (这是jquery包装了ajax方式)将表单提交到后台,表单提交一般都需要返回结果 ajax教程 https://www.w3cschool.cn/ajax/ajax-tutorial.htmlhttps://developer.mozilla.org/zh-CN/docs/Web/Guide/AJAX/Getting_Startedhttps://developer.mozilla.org/zh-CN/docs/Web/Guide/AJAX 在提交表单时，前端有集合表单数据的不同方式,应对不同的场景 jquery https://www.jquery123.com/category/attributes/https://api.jquery.com/https://jquery.cuishifeng.cn/get.htmlhttps://www.w3school.com.cn/jquery/index.asp https://www.cnblogs.com/zhuxiaojie/p/4783939.html https://www.kancloud.cn/lirg199/devnote/343374 简单的表单可以直接用变量和相应的数据复杂的表单可以用$(‘#formid’).serialize(),FormData,以及jquery.form.js(也就是jquery对ajax的一些封装对象和函数)单纯序列化无法传递文件，一般是FormData 关于FormData,MDN文档: https://developer.mozilla.org/zh-CN/docs/Web/API/FormData/Using_FormData_Objects 不同content-type,使用不同的注解,json 就用 @RequestBody，form 表单就用 @RequestParam 或不写，form-data 就用 MultipartFile。https://juejin.cn/post/7054441239839506446 HttpServletRequest可以兼容三种，属于比较底层的方式 不同的content-type https://blog.csdn.net/java_xxxx/article/details/81205315https://blog.csdn.net/cpxsxn/article/details/123818812 FormData 的函数 https://blog.csdn.net/WU5229485/article/details/84400315 后端接收前端数据的常用注解 https://blog.csdn.net/wphero/article/details/108260313@RequestBody 只能接收Json类数据 @RequestParam可以用于接收application&#x2F;x-www-form-urlencoded和multipart&#x2F;form-data类型的数据 当前端请求过于复杂，可以使用@RequestPart来接收对象https://juejin.cn/post/6983228289703739428 当表单数据比较简单时，可以使用注解@RequestParam@RequestBody获得表单数据https://blog.csdn.net/weixin_44752797/article/details/118446420 vue项目主要用axios,功能比ajax更强大,axios对ajax进行了增强和封装https://myoule.zhipin.com/questions/e1ed13dbd35e0e3etnVy39y1FVE~.htmlhttps://learn-anything.cn/axios https://www.cnblogs.com/zhuxiaojie/p/4783939.html 前后端主要用Json数据格式通信 FormData 后端接收数据方式，不同的数据格式，不同的通信方式，可能会用到不同的注解https://blog.csdn.net/ShiuHB/article/details/109674343 @RequestMapping 和 @ResponseBody的用法与区别https://juejin.cn/post/6844904180235108359 https://blog.csdn.net/magi1201/article/details/82226289 举个栗子，@RequestMapping(“&#x2F;reproductionByTransPlan”),HttpServletRequest request,和Model model三者组合就足够应付一般的页面转换，return 下一个页面即可(可能用到redirect:&#x2F;) 但是遇到post请求,又需要返回数据或者响应状态时，使用@ResponseBody https://www.csdn.net/tags/MtTakgysMTE3ODItYmxvZwO0O0OO0O0O.html http://www.codebaoku.com/it-java/it-java-244954.html https://juejin.cn/post/6844903648858734600 RequestBody一些知识 Javaweb HttpServletRequest request request.getParamter(String name);通过name获取值 request.getParamterValues(String name);通过name获取value值(一般用于复选框获取值) 代码片段 request.getParameterNames();直接获取表单所有对象的name值，返回值是枚举集合 request.getParameterMap();直接获取表单所有对象的name值以及数据 通过session来设置当前对话的共有属性 HttpSession session &#x3D; request.getSession(); session.setAttribute(“name”, attr); 通过model来添加视图属性数据有时间总结一下Model,ModelView等类的SpringMVC相关知识 querySelector和getElementById的区别https://www.jianshu.com/p/53b034979388https://www.cnblogs.com/Leophen/p/11241411.html几乎只有动态和静态的区别，也就是getElementById获取到的元素可以动态响应元素本身的改变以及getElmentById比querySelector的执行速度更高 在使用FormData遇到的坑: 前端代码: $.ajax(&#123; url:&#39;/taskSubmit&#39;, data:form, type: &#39;POST&#39;, dataType: &#39;json&#39;, contentType: false, processData: false, async: true, beforeSend: function (xhr) &#123; xhr.setRequestHeader(header, token) &#125;, success:function(data)&#123; &#125; error:function()&#123; &#125; &lt;form class=&quot;ui form&quot; id=&quot;scheduleSubmit&quot; name=&quot;scheduleSubmit&quot; method=&quot;post&quot; enctype=&quot;multipart/form-data&quot;&gt; (eror和success也是JavaScript事件，只不过AJAX将其包装在一起) 后端代码 @RequestMapping(value &#x3D; “&#x2F;taskSubmit”,method &#x3D; RequestMethod.POST) @ResponseBody public int taskSubmit(@RequestBody Map&lt;String, String&gt; map){ &#125; https://blog.csdn.net/qq_35246620/article/details/59620858 (@ResponseBody和@RequestBody的区别)这篇博客第二个代码展示将两者作用写反了https://www.cnblogs.com/guodefu909/p/4216327.html 这篇博客正确 https://blog.csdn.net/zhanglf02/article/details/78470219 明确提到@RequestBody不能将multipart&#x2F;form-data的数据绑定到入参中说明：request的body部分的数据编码格式由header部分的Content-Type指定。 所谓的注解其实类似于Python的方法包装器，将一些共有的功能需求抽取出来，方便代码重复利用 @Responsebody注解表示该方法的返回的结果直接写入 HTTP 响应正文中，一般在异步获取数据时使用；在使用@RequestMapping后，返回值通常解析为跳转路径，加上@Responsebody后返回结果不会被解析为跳转路径，而是直接写入HTTP 响应正文中。例如，异步获取json数据，加上@Responsebody注解后，就会直接返回json数据。@RequestBody注解则是将 HTTP 求正文插入方法中，使用适合的HttpMessageConverter将请求体写入某个对象。 报错415，同时前端FormData没有数据 因为@RequestBody 不能处理multipart&#x2F;form-data的数据 415错误 服务器无法处理请求附带的媒体格式https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Status/415https://blog.csdn.net/majinggogogo/article/details/78383772 https://www.cnblogs.com/cc-freiheit/p/10334755.html post400错误1、前端提交数据的字段名称或者是字段类型和后台的实体类不一致，导致无法封装；2、前端提交的到后台的数据应该是 json 字符串类型，而前端没有将对象转化为字符串类型； 无法使用jquery的语法 $(‘#id’)，获得FormData对象只能使用document.getElementById(“name”)来初始化FormData对象 前端使用Form, 后端使用HttpServletRequest获取后端报错，数据为空,而前端能够获得数据 后端使用一个对象接收数据,报415错误，无法接收 https://blog.csdn.net/qq_44695727/article/details/112277632 FormData用法详解https://blog.csdn.net/zqian1994/article/details/79635413?utm_medium=distribute.pc_feed_404.none-task-blog-2~default~BlogCommendFromBaidu~Rate-4-79635413-blog-null.pc_404_mixedpudn&amp;depth_1-utm_source=distribute.pc_feed_404.none-task-blog-2~default~BlogCommendFromBaidu~Rate-4-79635413-blog-null.pc_404_mixedpud 最终成功前次错误原因在于@RequestBody 用于Json对象数据而非自建对象数据 最终总结，FormData传输一个对象，所以contentType和processData都为false,否则可能报错415既然传输一个对象，那么后端也必须用一个相应的对象承接enctype&#x3D;”multipart&#x2F;form-data” 也可以使用，不会报错 终于解决了一个问题！！！ 以后如果前端传送文件过来 也许用到以下教程https://blog.csdn.net/weixin_44732635/article/details/120724605 https://zhuanlan.zhihu.com/p/75867734 https://www.chenpeman.top/archives/springmvc%E4%B8%ADrequestparam%E4%B8%8Erequestbody%E7%9A%84%E5%8C%BA%E5%88%AB%E4%B8%8E%E7%94%A8%E6%B3%95%E5%B9%B6%E5%AE%9E%E7%8E%B0%E6%96%87%E4%BB%B6%E4%B8%8E%E8%A1%A8%E5%8D%95%E5%90%8C%E6%97%B6%E6%8F%90%E4%BA%A4 也许可以用RequestParm获得数据 https://www.cnblogs.com/blogtech/p/11172168.html 报错400 https://www.runoob.com/w3cnote/http-400.html原因在于 @RequestParam 接收多个参数时 https://cloud.tencent.com/developer/article/1549149 最终成功 使用Map接收,enctype为multipart&#x2F;form-data依然可以成功(在上传文件时需要添加) 总结 https://www.cnblogs.com/dw3306/p/13691917.htmlhttps://blog.51cto.com/u_15304202/3105387https://cloud.tencent.com/developer/article/1549149https://blog.csdn.net/qq_44543508/article/details/101026720 后端在接收Array类型的数据时出现问题无论使用FormData对象接收，还是RequestParam注解，String类型的数据都可以，但是数组不行 使用了最简单的方式，在前端，将数组数据改为字符串，使用JSON.stringify()和contentType: ‘application&#x2F;json’,将数据从DOM中一一提出来发送过去，在后端用@RequestBody Map&lt;String,String&gt; map获得这些数据，然后得到的字符串转换为数组。这种方式无法传输文件 提交的文件需要判定是否为dat格式吗","categories":[{"name":"Java","slug":"Java","permalink":"http://localhost:4000/categories/Java/"}],"tags":[]},{"title":"JavaScript学习笔记","slug":"JavaScript学习笔记","date":"2022-07-25T03:34:19.000Z","updated":"2022-10-17T08:13:13.326Z","comments":true,"path":"2022/07/25/JavaScript学习笔记/","link":"","permalink":"http://localhost:4000/2022/07/25/JavaScript%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/","excerpt":"","text":"标记语言如HTML并不向计算机发出指令，而是被动地被读取，常用于格式化和链接 javascript 装饰器和转发 https://zh.javascript.info/call-apply-decorators教程中的上下文基本都是指得对象本身，即函数的this指向何处python的函数默认带有this装饰器就是以函数入口为参数的函数 https://zh.javascript.info/这个要多看，常看常新 不只是看懂会做会写，这样无非是按照规律复制粘贴罢了重要的是明白背后的原理，为什么这么做，有什么好处，意义在哪里，逻辑是什么 看懂技术思想，为了具体实现做了什么 按钮控件将文件路径传入文本框网上查到的资料有问题 promise脚本加载往往是异步的，这意味着会出现因为脚本尚未加载完毕，使用函数中的脚本报错的情况。 loadScript(&#39;/my/script.js&#39;); // 这个脚本有 &quot;function newFunction() &#123;…&#125;&quot; newFunction(); // 没有这个函数！ 要使用脚本，可以使用回调函数，并使用onload()等待脚本加载完毕，以及使用onerror处理错误情况 function loadScript(src, callback) &#123; let script = document.createElement(&#39;script&#39;); script.src = src; script.onload = () =&gt; callback(null, script); script.onerror = () =&gt; callback(new Error(`Script load error for $&#123;src&#125;`)); document.head.append(script); &#125; 但是以上方法在回调层数增多时会出现回调地狱的情形（层层嵌套，代码难以维护） loadScript(&#39;1.js&#39;, function(error, script) &#123; if (error) &#123; handleError(error); &#125; else &#123; // ... loadScript(&#39;2.js&#39;, function(error, script) &#123; if (error) &#123; handleError(error); &#125; else &#123; // ... loadScript(&#39;3.js&#39;, function(error, script) &#123; if (error) &#123; handleError(error); &#125; else &#123; // ...加载完所有脚本后继续 (*) &#125; &#125;); &#125; &#125;); &#125; &#125;); 可以使用Promise更简洁更完备地完成上述功能 let promise = new Promise(function(resolve, reject) &#123; // executor（生产者，消费者） &#125;); executor 会自动运行并尝试执行一项工作。尝试结束后，如果成功则调用 resolve，如果出现 error 则调用 reject。由 new Promise 构造器返回的 promise 对象具有以下内部属性：state —— 最初是 “pending”，然后在 resolve 被调用时变为 “fulfilled”，或者在 reject 被调用时变为 “rejected”。result —— 最初是 undefined，然后在 resolve(value) 被调用时变为 value，或者在 reject(error) 被调用时变为 error。 executor 只能调用一个 resolve 或一个 reject。任何状态的更改都是最终的。所有其他的再对 resolve 和 reject 的调用都会被忽略 使用.then语法 promise.then( function(result) { &#x2F;* handle a successful result &#x2F; }, function(error) { &#x2F; handle an error *&#x2F; } );可以使用catch来处理error,而.catch(f) 调用是 .then(null, f) 的完全的模拟，它只是一个简写形式。 finally类似于try catch finally finally 处理程序（handler）没有参数。在finally中，我们不知道promise是否成功。没关系，因为我们的任务通常是执行“常规”的完成程序（finalizing procedures）。请看上面的例子：如你所见，finally处理程序没有参数，promise的结果由下一个处理程序处理。finally处理程序将结果或 error“传递”给下一个合适的处理程序。 不断使用.then构建Promise链，每个对.then的调用都会返回了一个新的promisepromise常用于网络请求，也可以结合fetch 绑定事件函数的几个方法，以及不同之处 绑定事件函数JavaScript列表可以使用Array和[]来声明列表，直接给空列表赋值会改变列表长度并添加相应位置的元素，不会报错","categories":[{"name":"JavaScript","slug":"JavaScript","permalink":"http://localhost:4000/categories/JavaScript/"}],"tags":[]},{"title":"JWT总结","slug":"JWT总结","date":"2022-07-18T11:38:46.000Z","updated":"2022-08-24T05:46:56.893Z","comments":true,"path":"2022/07/18/JWT总结/","link":"","permalink":"http://localhost:4000/2022/07/18/JWT%E6%80%BB%E7%BB%93/","excerpt":"","text":"http://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html https://zhuanlan.zhihu.com/p/86937325 主要用于授权认证和信息交换 分为三个部分,每个部分用”.”分隔，即 xxx.yyy.zzz Header Payload Signature 将基于服务器的身份认证转换为基于客户端信息的认证方式，减轻了服务器的工作量，并且容易跨域认证，可以不用考虑多个服务器之间分享session信息的问题","categories":[{"name":"Java","slug":"Java","permalink":"http://localhost:4000/categories/Java/"}],"tags":[]},{"title":"Vue项目进展过程的坑","slug":"Vue项目进展过程的坑","date":"2022-07-18T11:36:24.000Z","updated":"2022-12-08T07:50:59.100Z","comments":true,"path":"2022/07/18/Vue项目进展过程的坑/","link":"","permalink":"http://localhost:4000/2022/07/18/Vue%E9%A1%B9%E7%9B%AE%E8%BF%9B%E5%B1%95%E8%BF%87%E7%A8%8B%E7%9A%84%E5%9D%91/","excerpt":"","text":"在做Vue项目时总是遇到各种奇形怪状的坑，特此记录，以备后用 高德地图前端绘制 https://github.com/ElemeFE/vue-amap 这是饿了么的amaphttps://lbs.amap.com/ 这是高德地图原生的 https://lbs.amap.com/api/jsapi-v2/guide/abc/prepare MyUI https://newgateway.gitee.io/my/ 新德汇地图 https://gitee.com/newgateway/xdh-map Surely Vue https://www.surely.cool/doc/guide semantic ui https://semantic-ui.com/elements/icon.html ant-design vue https://www.antdv.com/components/radio-cn 技巧npm view *** version 查看包目前发布了哪些版本 使用JSAPI Loader加载高德地图后，window下会出现AMap,AMapUI,Loca等属性 开发遇到的问题取数据时，页数设置，取到了不同数据，测试一下拿到了想要的数据 使用地图时无法使用JSAPI Loader，具体情形在 Vue前端使用高德地图 中。Vue CLI使用的webpack版本是4.46，而地图的NPM使用方式需要webpack5版本以上，无法使用，只能使用官网JS脚本添加最终找到原因，原项目中Less-loader版本过高，降低到7以后安装成功本项目是一个单页面web，通过路由跳转到相应的组件 打开IDEA，报错 project is not defined,在setup了之后，Java文件左下角出现橙色图标，找寻pom.xml文件，右键点击，add as Maven project，错误解决（在这之前其他许多办法都无法解决）https://blog.csdn.net/m0_46207055/article/details/113277609随时保存备份资料 Vue在methods中的方法无法直接获取data属性中的Array类型属性，如果直接根据索引得到的是[__ob__: Observer] 在网上搜索方法https://zhuanlan.zhihu.com/p/79091215https://blog.csdn.net/zhouzuoluo/article/details/103067637https://www.dounaite.com/article/627c98b6ac359fc9132d59af.html 以上教程说明 ob: Observer是 Vue 对数据监控添加的属性，不可枚举和遍历 JSON.parse(JSON.stringify(list)) Object.assign(&#123;&#125;,this.list) let newarr = Object.assign([],this.data).map(item =&gt; &#123;return Object.assign(&#123;&#125;,item)&#125;) 使用以上三种方法发现返回数据为空 https://blog.csdn.net/wenchangwenliu/article/details/121954177上面这个教程指出数据异步请求取用问题项目中数据从后端而来，最好使用success回调函数进行处理，我预估和我遇到的问题没有关系，因为我获取数据的函数在created阶段，打印数据也显示data中已经有数据，而使用数据在mounted阶段。 但是在回调函数中使用数据是个似乎可行的解决方式 https://blog.csdn.net/Ppphill_C/article/details/121066257 这个教程遇到了同样的问题，并且使用JSON.parse(JSON.stringify(数组))数组也为空，但是console.log()能够得到数据，而我在使用数据的函数中甚至console出来的还是空(只有[__ob__: Observer]) 在调试的过程中(使用console.log())，发现在created使用axios获得数据并且放在data属性中，在回调阶段还是能得到数据，不清楚是created和mounted这类不同阶段引起的变化还是因为data属性的特性 当把数据的处理阶段放在axios回调函数时，可以拿到数据经过实测，无论是mounted阶段还是created阶段，调用函数在改变data属性之后，this.data无法得到，而console.log(this)可以发现VueComponent存在这个data属性，应该是data属性无法直接取用 Vue的devtools无法看到组件内部的属性，难以调试 并且经过实测，window下可以得到AMap，但是却无法赋值给变量AMap 当mounted()里调用函数时，即便有前后顺序，当前面的函数对Vue组件的data属性有所改变的时候，或者为组件添加了一些属性，后面的函数完全察觉不到，怀疑是异步调用的问题 决定不使用函数，不调用函数，函数体全部在mounted()里，成功 也就是说，created()和mounted()最好不要调用methods()的函数，直接把函数体写出来 在devtools找到了组件以及相应的属性 可能是加载脚本太慢，可以尝试使用JS脚本引入，而非npm方法可以尝试使用promise链来解决问题 成功！！！ 原来就是promise链可以解决的问题，在于这些函数获得数据并不同步！！！ 总结，得到数据为[__ob__: Observer]原因就在于，数据根本还没拿到就开始处理了，第一个函数加载脚本和插件，后面拿不到AMap（或者window下还没有AMap）可能就是脚本还没加载完就开始做，同理，第二个函数请求数据，会出现，数据还没拿回来，第三个函数就开始处理。三个函数有个处理数据的顺序，一定要保证前者数据能够拿到，.then处理接下来的流程 全局变量设置刷新页面后找不到data中的AMap 使用data中的属性接收AMap，设置为全局变量Vue刷新页面找不到AMap对象 配置eslint文件，配置全局变量，仅仅只是eslint不报错了，浏览器环境依旧无法识别全局变量暂时只能使用data接收，并且设置刷新缓存 缺陷在于，拿到数据的时候，AMap还没有初始化，而非刷新丢失data属性解决办法是 使用computed打包属性，让watch监视的时候，保证AMap一定初始化完毕 看后端项目时，完全偏了应该有的目标，那时候专注于去学习Java语言本身的一些概念和Spring,Spring boot框架，以及一些诸如autowired，mapper,Scheduled等等Java注解，甚至还有JWT身份认证方式这类完全用不到的东西（看教程时想着全都学了）。还有前后端通信的一些方法，RequestBody,ResponseBody,RequestParam等等不同注解的使用范围，以及前端的XMLHttpRequest,ajax,axios等等请求方法和表单提交方法。 业务逻辑不可能纯看代码看出来的，每个变量背后代表什么意思，这样处理的逻辑是什么，没有注释，根本不可能看懂。 前端学习了html,CSS,Thymeleaf,JavaScript,Jquery,Vue,ES6等等 以及比如Gaode,leaflet这些地图插件库。","categories":[{"name":"Vue","slug":"Vue","permalink":"http://localhost:4000/categories/Vue/"}],"tags":[]},{"title":"学习资料收集","slug":"学习资料收集","date":"2022-07-18T07:39:36.000Z","updated":"2022-11-24T02:06:38.033Z","comments":true,"path":"2022/07/18/学习资料收集/","link":"","permalink":"http://localhost:4000/2022/07/18/%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99%E6%94%B6%E9%9B%86/","excerpt":"","text":"Java 基础、Servlet、JDBC、Maven、Spring、Spring MVC 和 MyBatis https://zq99299.github.io/java-tutorial/essential/io/fileOps.html#%E9%87%8A%E6%94%BE%E7%B3%BB%E7%BB%9F%E8%B5%84%E6%BA%90Java8教程https://www.liaoxuefeng.com/wiki/1252599548343744 Java教程 https://www.jc2182.com/ 一个基础教程 https://www.pdai.tech/ Java教程 https://www.twle.cn/ 这类教程很多 B站链接 https://www.bilibili.com/video/BV1PQ4y1P7hZ?p=4&amp;vd_source=e566061f8d6653c807847b31868afa8b 教程 https://markerhub.com/https://www.zhuawaba.com/post/17https://juejin.cn/post/6844903823966732302 MyBatis-Plus https://baomidou.com/ 学习JWT http://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.htmlhttps://zhuanlan.zhihu.com/p/86937325 github的mall项目 spring+mybatis https://github.com/macrozheng/mall以及 https://github.com/macrozheng/mall-learning B站后台管理项目https://www.bilibili.com/video/BV1QU4y1E7qo?spm_id_from=333.337.search-card.all.click&amp;vd_source=e566061f8d6653c807847b31868afa8b https://www.bilibili.com/video/BV1U44y1W77D/?spm_id_from=333.788.recommend_more_video.0&amp;vd_source=e566061f8d6653c807847b31868afa8b vue 项目实战 https://www.bilibili.com/video/BV1Vf4y1T7bw?spm_id_from=333.337.search-card.all.click&amp;vd_source=e566061f8d6653c807847b31868afa8b Javaweb 学习https://www.bilibili.com/video/BV1AS4y177xJ?spm_id_from=333.337.search-card.all.click&amp;vd_source=e566061f8d6653c807847b31868afa8b javascript 学习https://zh.javascript.info/ spring 学习 https://blog.csdn.net/dear_Alice_moon/article/details/83476784 Maven https://www.liaoxuefeng.com/wiki/1252599548343744/1309301146648610 webpack https://www.webpackjs.com/ java 枚举类型 https://blog.csdn.net/javazejian/article/details/71333103 注解类型 https://blog.csdn.net/javazejian/article/details/71860633 Java类型信息(Class对象)与反射机制 https://blog.csdn.net/javazejian/article/details/70768369 深入理解Java https://blog.csdn.net/javazejian/category_6190120.html spring 理解 https://juejin.cn/post/6844904081857708045 https://docs.spring.io/spring-framework/docs/current/reference/html/core.html#beans-introduction vue.js 调试方式 https://blog.csdn.net/high32/article/details/116570570 https://cn.vuejs.org/v2/cookbook/debugging-in-vscode.html vue CLI 以及 vue-devtools https://cli.vuejs.org/zh/guide/ vuex vue-router npm https://docs.npmjs.com/getting-started mapper mybatis xml vue https://github.com/bailicangdu/vue2-elm element-ui 以及 ant-design 有时间把个人技术博客完善一下 使用ldd查看可执行程序的依赖库","categories":[],"tags":[]},{"title":"建立技术博客","slug":"建立技术博客","date":"2022-07-18T06:47:30.000Z","updated":"2023-02-16T08:10:45.141Z","comments":true,"path":"2022/07/18/建立技术博客/","link":"","permalink":"http://localhost:4000/2022/07/18/%E5%BB%BA%E7%AB%8B%E6%8A%80%E6%9C%AF%E5%8D%9A%E5%AE%A2/","excerpt":"","text":"用Github新建了一个技术博客hexo官网 https://hexo.bootcss.com/docs/ 个人主页 https://shenwuyue-xie.github.io/ 模板使用： https://kyori.xyz/ 教程： https://blog.csdn.net/yaorongke/article/details/119089190https://zhuanlan.zhihu.com/p/26625249 以后可以尝试使用Jekyll搭建博客 可以尝试更换模板 在hexo官网主题上 https://hexo.io/themes/ hexo常用命令官网可查 https://hexo.bootcss.com/docs/commands.html npm install hexo -g #安装 npm update hexo -g #升级 hexo init #初始化 new$ hexo new [layout] &lt;title&gt; $ hexo new &quot;post title with whitespace&quot; 新建一篇文章。如果没有设置 layout 的话，默认使用 _config.yml 中的 default_layout 参数代替。如果标题包含空格的话，请使用引号括起来。 参数 描述 -p, --path 自定义新文章的路径 -r, --replace 如果存在同名文章，将其替换 -s, --slug 文章的 Slug，作为新文章的文件名和发布后的 URL 默认情况下，Hexo 会使用文章的标题来决定文章文件的路径。对于独立页面来说，Hexo 会创建一个以标题为名字的目录，并在目录中放置一个 index.md 文件。你可以使用 –path 参数来覆盖上述行为、自行决定文件的目录： hexo new page --path about/me &quot;About me&quot; 以上命令会创建一个 source&#x2F;about&#x2F;me.md 文件，同时 Front Matter 中的 title 为 “About me” 注意！title 是必须指定的！如果你这么做并不能达到你的目的： hexo new page --path about/me 此时 Hexo 会创建 source&#x2F;_posts&#x2F;about&#x2F;me.md，同时 me.md 的 Front Matter 中的 title 为 “page”。这是因为在上述命令中，hexo-cli 将 page 视为指定文章的标题、并采用默认的 layout。 generate$ hexo generate #生成静态文件 选项 描述 -d, --deploy 文件生成后立即部署网站 -w, --watch 监视文件变动 -b, --bail 生成过程中如果发生任何未处理的异常则抛出异常 -f, --force 强制重新生成文件 -c, --concurrency 最大同时生成文件的数量，默认无限制 Hexo 引入了差分机制，如果 public 目录存在，那么 hexo g 只会重新生成改动的文件。使用该参数的效果接近 hexo clean &amp;&amp; hexo generate 可以简写为 $ hexo g server$ hexo server 启动服务器。默认情况下，访问网址为： http://localhost:4000/ 选项 描述 -p, --port 重设端口 -s, --static 只使用静态文件 -l, --log 启动日记记录，使用覆盖记录格式 deploy$ hexo deploy 部署网站。 参数 描述 -g, --generate 部署之前预先生成静态文件 该命令可以简写为 $ hexo d hexo g -d 和 hexo d -g 效果相同 markdown列表语法 https://markdown.com.cn/basic-syntax/lists.html https://www.cnblogs.com/tcz1018/p/12996989.html 博客的一种类型，有时间了一定要自己折腾一个漂亮的 https://github.com/chanshiyucx 蝉时雨的github，他使用Vue创建博客前端，我也可以自己搭建出来尝试使用Aurora博客，https://www.cnblogs.com/liwangwang/p/12196130.htmlhttps://chanshiyu.com/#/post/41 npm install出问题 应该是node-sasshttps://blog.csdn.net/xiaoyuer_2020/article/details/119968089https://www.cnblogs.com/houxianzhou/p/15434089.html无法解决，该博客npm版本以及各种依赖包版本太旧了 https://github.com/Zou-Wang/CNblogs-Theme-Sakura https://github.com/mashirozx/sakura https://2heng.xin/theme-sakura/ 找到一个star 3k 的主题这个主题的hexo版本挺烂的，不如wordPress版本要么自己加看板娘和大屏图片 https://wu_aquarius.gitee.io/live2d/ 添加了一个简单的看板娘 其模型仓库是https://github.com/xiazeyu/live2d-widget-modelshexo博客添加看板娘 在github上搜索live2d-widget就有相应的看板娘模板 https://github.com/stevenjoezhang/live2d-widget 这是一个star 6.7k的看板娘模板使用成功http://blog.itchenliang.club/posts/22350780-f32d-11ea-bb4a-d3e1cbe3d592/ 这个教程有错误，没有在主题layout中引用看板娘JS文件，能出来个屁！！！！！！！ 这个教程只能适用于butterfly主题 https://learnku.com/articles/70368 使用这个教程成功了 搭建CDN建图床https://developer.aliyun.com/article/893254https://developer.aliyun.com/article/920046picgo是图片快速上传工具使用github作为图床工具，github的release用于发布软件工具文件等，因此也可以通过此链接下载图片 在本地两个不同的文件夹都可以push到github的同一个仓库，明明远程仓库改变了，但是pages却没变，并且pages的标签图还是原来的github只能是一个本地仓库连接到一个或者多个远程仓库，除非建立多个分支 可能和主题有关系，其public中的index.html是个空文件 重新搭建博客，使用主题，发现主题有问题，hexo g以后index.html为空！！！！！！！！！！！！！！！页面根本没有东西hexo s 命令后，能够生成博客，但是配属在github pages上出问题，原因就在于Public中的index.html为空 查到的原因大概率是因为hexo版本太低了https://alanlee.fun/2021/02/28/hexo-empty-html/https://blog.csdn.net/qq_41507243/article/details/104433464hexo version是3.9.0更新过程一直报错cnpm install -g npm-check一直报错真的是什么错误都能遇上发现cnpm真的不能用，出一堆问题崩溃，总算生成了，在一通升级以后，发现index.html可以生成了github生成成功！！最终确定是版本太落后，导致无法生成index.html 直接在github上搜索hexo theme也有很多主题","categories":[{"name":"hexo","slug":"hexo","permalink":"http://localhost:4000/categories/hexo/"}],"tags":[]},{"title":"测试文章","slug":"测试文章","date":"2022-07-18T01:47:08.000Z","updated":"2022-07-18T01:50:06.279Z","comments":true,"path":"2022/07/18/测试文章/","link":"","permalink":"http://localhost:4000/2022/07/18/%E6%B5%8B%E8%AF%95%E6%96%87%E7%AB%A0/","excerpt":"","text":"","categories":[],"tags":[]}],"categories":[{"name":"Vue","slug":"Vue","permalink":"http://localhost:4000/categories/Vue/"},{"name":"JavaScript","slug":"JavaScript","permalink":"http://localhost:4000/categories/JavaScript/"},{"name":"vue","slug":"vue","permalink":"http://localhost:4000/categories/vue/"},{"name":"Java","slug":"Java","permalink":"http://localhost:4000/categories/Java/"},{"name":"hexo","slug":"hexo","permalink":"http://localhost:4000/categories/hexo/"}],"tags":[{"name":"Java IO","slug":"Java-IO","permalink":"http://localhost:4000/tags/Java-IO/"},{"name":"IDE","slug":"IDE","permalink":"http://localhost:4000/tags/IDE/"}]}